{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebUSB = exports.getWebUsb = void 0;\n\nvar usb = require(\"../usb\");\n\nvar events_1 = require(\"events\");\n\nvar webusb_device_1 = require(\"./webusb-device\");\n/**\n * Convenience method to get the WebUSB interface available\n */\n\n\nvar getWebUsb = function () {\n  if (navigator && navigator.usb) {\n    return navigator.usb;\n  }\n\n  return new WebUSB();\n};\n\nexports.getWebUsb = getWebUsb;\n\nvar WebUSB =\n/** @class */\nfunction () {\n  function WebUSB(options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = options;\n    this.emitter = new events_1.EventEmitter();\n    this.knownDevices = new Map();\n    this.allowedDevices = options.allowedDevices || [];\n\n    var deviceConnectCallback = function (device) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var webDevice, deviceId, event_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , webusb_device_1.WebUSBDevice.createInstance(device)];\n\n            case 1:\n              webDevice = _a.sent(); // When connected, emit an event if it is an allowed device\n\n              if (webDevice && this.isAllowedDevice(webDevice)) {\n                deviceId = this.getDeviceId(device);\n\n                if (deviceId) {\n                  this.knownDevices.set(deviceId, webDevice);\n                }\n\n                event_1 = {\n                  type: 'connect',\n                  device: webDevice\n                };\n                this.emitter.emit('connect', event_1);\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    var deviceDisconnectCallback = function (device) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var deviceId, webDevice, event_2;\n        return __generator(this, function (_a) {\n          deviceId = this.getDeviceId(device); // When disconnected, emit an event if the device was a known allowed device\n\n          if (deviceId !== undefined && this.knownDevices.has(deviceId)) {\n            webDevice = this.knownDevices.get(deviceId);\n\n            if (webDevice && this.isAllowedDevice(webDevice)) {\n              event_2 = {\n                type: 'disconnect',\n                device: webDevice\n              };\n              this.emitter.emit('disconnect', event_2);\n            }\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n\n    this.emitter.on('newListener', function (event) {\n      var listenerCount = _this.emitter.listenerCount(event);\n\n      if (listenerCount !== 0) {\n        return;\n      }\n\n      if (event === 'connect') {\n        usb.addListener('attach', deviceConnectCallback);\n      } else if (event === 'disconnect') {\n        usb.addListener('detach', deviceDisconnectCallback);\n      }\n    });\n    this.emitter.on('removeListener', function (event) {\n      var listenerCount = _this.emitter.listenerCount(event);\n\n      if (listenerCount !== 0) {\n        return;\n      }\n\n      if (event === 'connect') {\n        usb.removeListener('attach', deviceConnectCallback);\n      } else if (event === 'disconnect') {\n        usb.removeListener('detach', deviceDisconnectCallback);\n      }\n    });\n  }\n\n  Object.defineProperty(WebUSB.prototype, \"onconnect\", {\n    set: function (fn) {\n      if (this._onconnect) {\n        this.removeEventListener('connect', this._onconnect);\n        this._onconnect = undefined;\n      }\n\n      if (fn) {\n        this._onconnect = fn;\n        this.addEventListener('connect', this._onconnect);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebUSB.prototype, \"ondisconnect\", {\n    set: function (fn) {\n      if (this._ondisconnect) {\n        this.removeEventListener('disconnect', this._ondisconnect);\n        this._ondisconnect = undefined;\n      }\n\n      if (fn) {\n        this._ondisconnect = fn;\n        this.addEventListener('disconnect', this._ondisconnect);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebUSB.prototype.addEventListener = function (type, listener) {\n    this.emitter.addListener(type, listener);\n  };\n\n  WebUSB.prototype.removeEventListener = function (type, callback) {\n    this.emitter.removeListener(type, callback);\n  };\n\n  WebUSB.prototype.dispatchEvent = function (_event) {\n    // Don't dispatch from here\n    return false;\n  };\n  /**\n   * Requests a single Web USB device\n   * @param options The options to use when scanning\n   * @returns Promise containing the selected device\n   */\n\n\n  WebUSB.prototype.requestDevice = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var devices, device, _a, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // Must have options\n            if (!options) {\n              throw new TypeError('requestDevice error: 1 argument required, but only 0 present');\n            } // Options must be an object\n\n\n            if (options.constructor !== {}.constructor) {\n              throw new TypeError('requestDevice error: parameter 1 (options) is not an object');\n            } // Must have a filter\n\n\n            if (!options.filters) {\n              throw new TypeError('requestDevice error: required member filters is undefined');\n            } // Filter must be an array\n\n\n            if (options.filters.constructor !== [].constructor) {\n              throw new TypeError('requestDevice error: the provided value cannot be converted to a sequence');\n            } // Check filters\n\n\n            options.filters.forEach(function (filter) {\n              // Protocol & Subclass\n              if (filter.protocolCode && !filter.subclassCode) {\n                throw new TypeError('requestDevice error: subclass code is required');\n              } // Subclass & Class\n\n\n              if (filter.subclassCode && !filter.classCode) {\n                throw new TypeError('requestDevice error: class code is required');\n              }\n            });\n            return [4\n            /*yield*/\n            , this.loadDevices(options.filters)];\n\n          case 1:\n            devices = _b.sent();\n            devices = devices.filter(function (device) {\n              return _this.filterDevice(options, device);\n            });\n\n            if (devices.length === 0) {\n              throw new Error('requestDevice error: no devices found');\n            }\n\n            _b.label = 2;\n\n          case 2:\n            _b.trys.push([2, 6,, 7]);\n\n            if (!this.options.devicesFound) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.options.devicesFound(devices)];\n\n          case 3:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            _a = devices[0];\n            _b.label = 5;\n\n          case 5:\n            device = _a;\n\n            if (!device) {\n              throw new Error('selected device not found');\n            }\n\n            if (!this.isAllowedDevice(device)) {\n              this.allowedDevices.push({\n                vendorId: device.vendorId,\n                productId: device.productId,\n                serialNumber: device.serialNumber\n              });\n            }\n\n            return [2\n            /*return*/\n            , device];\n\n          case 6:\n            error_1 = _b.sent();\n            throw new Error(\"requestDevice error: \" + error_1);\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Gets all allowed Web USB devices which are connected\n   * @returns Promise containing an array of devices\n   */\n\n\n  WebUSB.prototype.getDevices = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var preFilters, devices;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.options.allowAllDevices) {\n              // Create pre-filters\n              preFilters = this.allowedDevices.map(function (device) {\n                return {\n                  vendorId: device.vendorId || undefined,\n                  productId: device.productId || undefined,\n                  serialNumber: device.serialNumber || undefined\n                };\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.loadDevices(preFilters)];\n\n          case 1:\n            devices = _a.sent();\n            return [2\n            /*return*/\n            , devices.filter(function (device) {\n              return _this.isAllowedDevice(device);\n            })];\n        }\n      });\n    });\n  };\n\n  WebUSB.prototype.loadDevices = function (preFilters) {\n    return __awaiter(this, void 0, void 0, function () {\n      var devices, webDevices, devices_1, devices_1_1, device, webDevice, deviceId, e_1_1;\n\n      var e_1, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            devices = usb.getDeviceList(); // Pre-filter devices\n\n            devices = this.preFilterDevices(devices, preFilters);\n            webDevices = [];\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 6, 7, 8]);\n\n            devices_1 = __values(devices), devices_1_1 = devices_1.next();\n            _b.label = 2;\n\n          case 2:\n            if (!!devices_1_1.done) return [3\n            /*break*/\n            , 5];\n            device = devices_1_1.value;\n\n            if (this.options.deviceTimeout) {\n              device.timeout = this.options.deviceTimeout;\n            }\n\n            return [4\n            /*yield*/\n            , webusb_device_1.WebUSBDevice.createInstance(device)];\n\n          case 3:\n            webDevice = _b.sent();\n\n            if (webDevice) {\n              webDevices.push(webDevice);\n              deviceId = this.getDeviceId(device);\n\n              if (deviceId) {\n                this.knownDevices.set(deviceId, webDevice);\n              }\n            }\n\n            _b.label = 4;\n\n          case 4:\n            devices_1_1 = devices_1.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            e_1_1 = _b.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            try {\n              if (devices_1_1 && !devices_1_1.done && (_a = devices_1.return)) _a.call(devices_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            , webDevices];\n        }\n      });\n    });\n  };\n\n  WebUSB.prototype.preFilterDevices = function (devices, preFilters) {\n    if (!preFilters || !preFilters.length) {\n      return devices;\n    } // Just pre-filter on vid/pid\n\n\n    return devices.filter(function (device) {\n      return preFilters.some(function (filter) {\n        // Vendor\n        if (filter.vendorId && filter.vendorId !== device.deviceDescriptor.idVendor) return false; // Product\n\n        if (filter.productId && filter.productId !== device.deviceDescriptor.idProduct) return false; // Ignore serial number for node-usb as it requires device connection\n\n        return true;\n      });\n    });\n  };\n\n  WebUSB.prototype.filterDevice = function (options, device) {\n    if (!options.filters || !options.filters.length) {\n      return true;\n    }\n\n    return options.filters.some(function (filter) {\n      // Vendor\n      if (filter.vendorId && filter.vendorId !== device.vendorId) return false; // Product\n\n      if (filter.productId && filter.productId !== device.productId) return false; // Class\n\n      if (filter.classCode) {\n        if (!device.configuration) {\n          return false;\n        } // Interface Descriptors\n\n\n        var match = device.configuration.interfaces.some(function (iface) {\n          // Class\n          if (filter.classCode && filter.classCode !== iface.alternate.interfaceClass) return false; // Subclass\n\n          if (filter.subclassCode && filter.subclassCode !== iface.alternate.interfaceSubclass) return false; // Protocol\n\n          if (filter.protocolCode && filter.protocolCode !== iface.alternate.interfaceProtocol) return false;\n          return true;\n        });\n\n        if (match) {\n          return true;\n        }\n      } // Class\n\n\n      if (filter.classCode && filter.classCode !== device.deviceClass) return false; // Subclass\n\n      if (filter.subclassCode && filter.subclassCode !== device.deviceSubclass) return false; // Protocol\n\n      if (filter.protocolCode && filter.protocolCode !== device.deviceProtocol) return false; // Serial\n\n      if (filter.serialNumber && filter.serialNumber !== device.serialNumber) return false;\n      return true;\n    });\n  };\n\n  WebUSB.prototype.getDeviceId = function (device) {\n    if (device.busNumber === undefined || device.deviceAddress === undefined) {\n      return undefined;\n    }\n\n    return device.busNumber + \".\" + device.deviceAddress;\n  };\n\n  WebUSB.prototype.isAllowedDevice = function (device) {\n    if (this.options.allowAllDevices) {\n      return true;\n    }\n\n    var isSameDevice = function (device1, device2) {\n      return device1.productId === device2.productId && device1.vendorId === device2.vendorId && device1.serialNumber === device2.serialNumber;\n    };\n\n    for (var i in this.allowedDevices) {\n      if (isSameDevice(device, this.allowedDevices[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return WebUSB;\n}();\n\nexports.WebUSB = WebUSB;","map":{"version":3,"mappings":"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","names":["getWebUsb","navigator","usb","WebUSB","exports","options","events_1","Map","allowedDevices","deviceConnectCallback","device","webusb_device_1","createInstance","webDevice","_a","isAllowedDevice","deviceId","getDeviceId","knownDevices","set","event_1","type","emitter","emit","deviceDisconnectCallback","undefined","has","get","event_2","on","listenerCount","_this","event","addListener","removeListener","Object","fn","_onconnect","removeEventListener","addEventListener","_ondisconnect","listener","callback","_event","TypeError","constructor","filters","forEach","filter","protocolCode","subclassCode","classCode","loadDevices","devices","_b","filterDevice","length","Error","devicesFound","push","vendorId","productId","serialNumber","error_1","allowAllDevices","preFilters","map","getDeviceList","preFilterDevices","webDevices","devices_1","devices_1_1","deviceTimeout","timeout","some","deviceDescriptor","idVendor","idProduct","configuration","match","interfaces","iface","alternate","interfaceClass","interfaceSubclass","interfaceProtocol","deviceClass","deviceSubclass","deviceProtocol","busNumber","deviceAddress","isSameDevice","device1","device2","i"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\webusb\\index.ts"],"sourcesContent":["import * as usb from '../usb';\nimport { EventEmitter } from 'events';\nimport { WebUSBDevice } from './webusb-device';\n\n/**\n * USB Options\n */\nexport interface USBOptions {\n    /**\n     * Optional `device found` callback function to allow the user to select a device\n     */\n    devicesFound?: (devices: USBDevice[]) => Promise<USBDevice | void>;\n\n    /**\n     * Optional array of preconfigured allowed devices\n     */\n    allowedDevices?: USBDeviceFilter[];\n\n    /**\n     * Optional flag to automatically allow all devices\n     */\n    allowAllDevices?: boolean;\n\n    /**\n     * Optional timeout (in milliseconds) to use for the device control transfers\n     */\n    deviceTimeout?: number;\n}\n\n/**\n * Convenience method to get the WebUSB interface available\n */\nexport const getWebUsb = (): USB => {\n    if (navigator && navigator.usb) {\n        return navigator.usb;\n    }\n\n    return new WebUSB();\n};\n\nexport class WebUSB implements USB {\n\n    protected emitter = new EventEmitter();\n    protected knownDevices: Map<string, USBDevice> = new Map();\n    protected allowedDevices: USBDeviceFilter[];\n\n    constructor(private options: USBOptions = {}) {\n        this.allowedDevices = options.allowedDevices || [];\n\n        const deviceConnectCallback = async (device: usb.Device) => {\n            const webDevice = await WebUSBDevice.createInstance(device);\n\n            // When connected, emit an event if it is an allowed device\n            if (webDevice && this.isAllowedDevice(webDevice)) {\n                const deviceId = this.getDeviceId(device);\n                if (deviceId) {\n                    this.knownDevices.set(deviceId, webDevice);\n                }\n\n                const event = {\n                    type: 'connect',\n                    device: webDevice\n                };\n\n                this.emitter.emit('connect', event);\n            }\n        };\n\n        const deviceDisconnectCallback = async (device: usb.Device) => {\n            const deviceId = this.getDeviceId(device);\n\n            // When disconnected, emit an event if the device was a known allowed device\n            if (deviceId !== undefined && this.knownDevices.has(deviceId)) {\n                const webDevice = this.knownDevices.get(deviceId);\n\n                if (webDevice && this.isAllowedDevice(webDevice)) {\n                    const event = {\n                        type: 'disconnect',\n                        device: webDevice\n                    };\n\n                    this.emitter.emit('disconnect', event);\n                }\n            }\n        };\n\n        this.emitter.on('newListener', event => {\n            const listenerCount = this.emitter.listenerCount(event);\n\n            if (listenerCount !== 0) {\n                return;\n            }\n\n            if (event === 'connect') {\n                usb.addListener('attach', deviceConnectCallback);\n            } else if (event === 'disconnect') {\n                usb.addListener('detach', deviceDisconnectCallback);\n            }\n        });\n\n        this.emitter.on('removeListener', event => {\n            const listenerCount = this.emitter.listenerCount(event);\n\n            if (listenerCount !== 0) {\n                return;\n            }\n\n            if (event === 'connect') {\n                usb.removeListener('attach', deviceConnectCallback);\n            } else if (event === 'disconnect') {\n                usb.removeListener('detach', deviceDisconnectCallback);\n            }\n        });\n    }\n\n    private _onconnect: ((ev: USBConnectionEvent) => void) | undefined;\n    public set onconnect(fn: (ev: USBConnectionEvent) => void) {\n        if (this._onconnect) {\n            this.removeEventListener('connect', this._onconnect);\n            this._onconnect = undefined;\n        }\n\n        if (fn) {\n            this._onconnect = fn;\n            this.addEventListener('connect', this._onconnect);\n        }\n    }\n\n    private _ondisconnect: ((ev: USBConnectionEvent) => void) | undefined;\n    public set ondisconnect(fn: (ev: USBConnectionEvent) => void) {\n        if (this._ondisconnect) {\n            this.removeEventListener('disconnect', this._ondisconnect);\n            this._ondisconnect = undefined;\n        }\n\n        if (fn) {\n            this._ondisconnect = fn;\n            this.addEventListener('disconnect', this._ondisconnect);\n        }\n    }\n\n    public addEventListener(type: 'connect' | 'disconnect', listener: (this: this, ev: USBConnectionEvent) => void): void;\n    public addEventListener(type: 'connect' | 'disconnect', listener: EventListener): void;\n    public addEventListener(type: string, listener: (ev: USBConnectionEvent) => void): void {\n        this.emitter.addListener(type, listener);\n    }\n\n    public removeEventListener(type: 'connect' | 'disconnect', callback: (this: this, ev: USBConnectionEvent) => void): void;\n    public removeEventListener(type: 'connect' | 'disconnect', callback: EventListener): void;\n    public removeEventListener(type: string, callback: (this: this, ev: USBConnectionEvent) => void): void {\n        this.emitter.removeListener(type, callback);\n    }\n\n    public dispatchEvent(_event: Event): boolean {\n        // Don't dispatch from here\n        return false;\n    }\n\n    /**\n     * Requests a single Web USB device\n     * @param options The options to use when scanning\n     * @returns Promise containing the selected device\n     */\n    public async requestDevice(options?: USBDeviceRequestOptions): Promise<USBDevice> {\n        // Must have options\n        if (!options) {\n            throw new TypeError('requestDevice error: 1 argument required, but only 0 present');\n        }\n\n        // Options must be an object\n        if (options.constructor !== {}.constructor) {\n            throw new TypeError('requestDevice error: parameter 1 (options) is not an object');\n        }\n\n        // Must have a filter\n        if (!options.filters) {\n            throw new TypeError('requestDevice error: required member filters is undefined');\n        }\n\n        // Filter must be an array\n        if (options.filters.constructor !== [].constructor) {\n            throw new TypeError('requestDevice error: the provided value cannot be converted to a sequence');\n        }\n\n        // Check filters\n        options.filters.forEach(filter => {\n            // Protocol & Subclass\n            if (filter.protocolCode && !filter.subclassCode) {\n                throw new TypeError('requestDevice error: subclass code is required');\n            }\n\n            // Subclass & Class\n            if (filter.subclassCode && !filter.classCode) {\n                throw new TypeError('requestDevice error: class code is required');\n            }\n        });\n\n        let devices = await this.loadDevices(options.filters);\n        devices = devices.filter(device => this.filterDevice(options, device));\n\n        if (devices.length === 0) {\n            throw new Error('requestDevice error: no devices found');\n        }\n\n        try {\n            // If no devicesFound function, select the first device found\n            const device = this.options.devicesFound ? await this.options.devicesFound(devices) : devices[0];\n\n            if (!device) {\n                throw new Error('selected device not found');\n            }\n\n            if (!this.isAllowedDevice(device)) {\n                this.allowedDevices.push({\n                    vendorId: device.vendorId,\n                    productId: device.productId,\n                    serialNumber: device.serialNumber\n                });\n            }\n\n            return device;\n        } catch (error) {\n            throw new Error(`requestDevice error: ${error}`);\n        }\n    }\n\n    /**\n     * Gets all allowed Web USB devices which are connected\n     * @returns Promise containing an array of devices\n     */\n    public async getDevices(): Promise<USBDevice[]> {\n        let preFilters: USBDeviceFilter[] | undefined;\n\n        if (!this.options.allowAllDevices) {\n            // Create pre-filters\n            preFilters = this.allowedDevices.map(device => ({\n                vendorId: device.vendorId || undefined,\n                productId: device.productId || undefined,\n                serialNumber: device.serialNumber || undefined\n            }));\n        }\n\n        // Refresh devices and filter for allowed ones\n        const devices = await this.loadDevices(preFilters);\n        return devices.filter(device => this.isAllowedDevice(device));\n    }\n\n    private async loadDevices(preFilters?: USBDeviceFilter[]): Promise<USBDevice[]> {\n        let devices = usb.getDeviceList();\n\n        // Pre-filter devices\n        devices = this.preFilterDevices(devices, preFilters);\n\n        const webDevices: USBDevice[] = [];\n\n        for (const device of devices) {\n            if (this.options.deviceTimeout) {\n                device.timeout = this.options.deviceTimeout;\n            }\n\n            const webDevice = await WebUSBDevice.createInstance(device);\n            if (webDevice) {\n                webDevices.push(webDevice);\n\n                const deviceId = this.getDeviceId(device);\n                if (deviceId) {\n                    this.knownDevices.set(deviceId, webDevice);\n                }\n            }\n        }\n\n        return webDevices;\n    }\n\n    private preFilterDevices(devices: usb.Device[], preFilters?: USBDeviceFilter[]): usb.Device[] {\n        if (!preFilters || !preFilters.length) {\n            return devices;\n        }\n\n        // Just pre-filter on vid/pid\n        return devices.filter(device => preFilters.some(filter => {\n            // Vendor\n            if (filter.vendorId && filter.vendorId !== device.deviceDescriptor.idVendor) return false;\n\n            // Product\n            if (filter.productId && filter.productId !== device.deviceDescriptor.idProduct) return false;\n\n            // Ignore serial number for node-usb as it requires device connection\n            return true;\n        }));\n    }\n\n    private filterDevice(options: USBDeviceRequestOptions, device: USBDevice): boolean {\n        if (!options.filters || !options.filters.length) {\n            return true;\n        }\n\n        return options.filters.some(filter => {\n            // Vendor\n            if (filter.vendorId && filter.vendorId !== device.vendorId) return false;\n\n            // Product\n            if (filter.productId && filter.productId !== device.productId) return false;\n\n            // Class\n            if (filter.classCode) {\n\n                if (!device.configuration) {\n                    return false;\n                }\n\n                // Interface Descriptors\n                const match = device.configuration.interfaces.some(iface => {\n                    // Class\n                    if (filter.classCode && filter.classCode !== iface.alternate.interfaceClass) return false;\n\n                    // Subclass\n                    if (filter.subclassCode && filter.subclassCode !== iface.alternate.interfaceSubclass) return false;\n\n                    // Protocol\n                    if (filter.protocolCode && filter.protocolCode !== iface.alternate.interfaceProtocol) return false;\n\n                    return true;\n                });\n\n                if (match) {\n                    return true;\n                }\n            }\n\n            // Class\n            if (filter.classCode && filter.classCode !== device.deviceClass) return false;\n\n            // Subclass\n            if (filter.subclassCode && filter.subclassCode !== device.deviceSubclass) return false;\n\n            // Protocol\n            if (filter.protocolCode && filter.protocolCode !== device.deviceProtocol) return false;\n\n            // Serial\n            if (filter.serialNumber && filter.serialNumber !== device.serialNumber) return false;\n\n            return true;\n        });\n    }\n\n    private getDeviceId(device: usb.Device): string | undefined {\n        if (device.busNumber === undefined || device.deviceAddress === undefined) {\n            return undefined;\n        }\n\n        return `${device.busNumber}.${device.deviceAddress}`;\n    }\n\n    private isAllowedDevice(device: USBDeviceFilter): boolean {\n        if (this.options.allowAllDevices) {\n            return true;\n        }\n\n        const isSameDevice = (device1: USBDeviceFilter, device2: USBDeviceFilter): boolean => {\n            return (device1.productId === device2.productId\n                && device1.vendorId === device2.vendorId\n                && device1.serialNumber === device2.serialNumber);\n        };\n\n        for (const i in this.allowedDevices) {\n            if (isSameDevice(device, this.allowedDevices[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}