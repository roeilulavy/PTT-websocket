{"ast":null,"code":"\"use strict\"; // Definitions from DefinitelyTyped, thanks to:\n//  Eric Brody <https://github.com/underscorebrody>\n//  Rob Moran <https://github.com/thegecko>\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path_1 = require(\"path\");\n/* eslint-disable @typescript-eslint/no-var-requires */\n\n\nvar usb = require('node-gyp-build')(path_1.join(__dirname, '..', '..'));\n\nmodule.exports = usb;","map":{"version":3,"mappings":"cAAA;AACA;AACA;;;;;;AAEA;AAGA;;;AACA,IAAMA,GAAG,GAAGC,OAAO,CAAC,gBAAD,CAAP,CAA0BC,YAAKC,SAAL,EAAgB,IAAhB,EAAsB,IAAtB,CAA1B,CAAZ;;AACAC,MAAM,CAACC,OAAP,GAAiBL,GAAjB","names":["usb","require","path_1","__dirname","module","exports"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\usb\\bindings.ts"],"sourcesContent":["// Definitions from DefinitelyTyped, thanks to:\n//  Eric Brody <https://github.com/underscorebrody>\n//  Rob Moran <https://github.com/thegecko>\n\nimport { join } from 'path';\nimport type { DeviceDescriptor, ConfigDescriptor, BosDescriptor } from './descriptors';\n\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst usb = require('node-gyp-build')(join(__dirname, '..', '..'));\nmodule.exports = usb;\n\n/**\n * Return a list of `Device` objects for the USB devices attached to the system.\n */\nexport declare function getDeviceList(): Device[];\n\nexport declare const INIT_ERROR: number;\n\nexport declare class LibUSBException extends Error {\n    errno: number;\n}\n\n/**\n * Set the libusb debug level (between 0 and 4)\n * @param level libusb debug level (between 0 and 4)\n */\nexport declare function setDebugLevel(level: number): void;\n\n/**\n * Use USBDK Backend (Windows only)\n */\nexport declare function useUsbDkBackend(): void;\n\nexport declare function _enableHotplugEvents(): void;\nexport declare function _disableHotplugEvents(): void;\nexport declare function _getLibusbCapability(capability: number): number;\n\n/**\n * Restore (re-reference) the hotplug events unreferenced by `unrefHotplugEvents()`\n */\nexport declare function refHotplugEvents(): void;\n\n/**\n * Unreference the hotplug events from the event loop, allowing the process to exit even when listening for the `attach` and `detach` events\n */\nexport declare function unrefHotplugEvents(): void;\n\n/** Represents a USB transfer */\nexport declare class Transfer {\n    constructor(device: Device, endpointAddr: number, type: number, timeout: number, callback: (error: LibUSBException, buf: Buffer, actual: number) => void);\n\n    /**\n     * (Re-)submit the transfer.\n     *\n     * @param buffer Buffer where data will be written (for IN transfers) or read from (for OUT transfers).\n     */\n    submit(buffer: Buffer, callback?: (error: LibUSBException | undefined, buffer: Buffer, actualLength: number) => void): Transfer;\n\n    /**\n     * Cancel the transfer.\n     *\n     * Returns `true` if the transfer was canceled, `false` if it wasn't in pending state.\n     */\n    cancel(): boolean;\n}\n\n/** Represents a USB device. */\nexport declare class Device {\n    /** Integer USB device number */\n    busNumber: number;\n\n    /** Integer USB device address */\n    deviceAddress: number;\n\n    /** Array containing the USB device port numbers, or `undefined` if not supported on this platform. */\n    portNumbers: number[];\n\n    /** Object with properties for the fields of the device descriptor. */\n    deviceDescriptor: DeviceDescriptor;\n\n    _bosDescriptor?: BosDescriptor;\n\n    __open(): void;\n    __close(): void;\n    __getParent(): Device;\n    __getConfigDescriptor(): ConfigDescriptor;\n    __getAllConfigDescriptors(): ConfigDescriptor[];\n    __setConfiguration(desired: number, callback: (error?: LibUSBException) => void): void;\n    __clearHalt(addr: number, callback: (error?: LibUSBException) => void): void;\n    __setInterface(addr: number, altSetting: number, callback: (error?: LibUSBException) => void): void;\n    __claimInterface(addr: number): void;\n    __releaseInterface(addr: number, callback: (error?: LibUSBException) => void): void;\n    __detachKernelDriver(addr: number): void;\n    __attachKernelDriver(addr: number): void;\n    __isKernelDriverActive(addr: number): boolean;\n\n    /**\n    * Performs a reset of the device. Callback is called when complete.\n    *\n    * The device must be open to use this method.\n    * @param callback\n    */\n    reset(callback: (error?: LibUSBException) => void): void;\n}\n\n/**\n * In the context of a \\ref libusb_device_descriptor \"device descriptor\",\n * this bDeviceClass value indicates that each interface specifies its\n * own class information and all interfaces operate independently.\n */\nexport declare const LIBUSB_CLASS_PER_INTERFACE: number;\n/** Audio class */\nexport declare const LIBUSB_CLASS_AUDIO: number;\n/** Communications class */\nexport declare const LIBUSB_CLASS_COMM: number;\n/** Human Interface Device class */\nexport declare const LIBUSB_CLASS_HID: number;\n/** Printer class */\nexport declare const LIBUSB_CLASS_PRINTER: number;\n/** Image class */\nexport declare const LIBUSB_CLASS_PTP: number;\n/** Mass storage class */\nexport declare const LIBUSB_CLASS_MASS_STORAGE: number;\n/** Hub class */\nexport declare const LIBUSB_CLASS_HUB: number;\n/** Data class */\nexport declare const LIBUSB_CLASS_DATA: number;\n/** Wireless class */\nexport declare const LIBUSB_CLASS_WIRELESS: number;\n/** Application class */\nexport declare const LIBUSB_CLASS_APPLICATION: number;\n/** Class is vendor-specific */\nexport declare const LIBUSB_CLASS_VENDOR_SPEC: number;\n\n// libusb_standard_request\n/** Request status of the specific recipient */\nexport declare const LIBUSB_REQUEST_GET_STATUS: number;\n/** Clear or disable a specific feature */\nexport declare const LIBUSB_REQUEST_CLEAR_FEATURE: number;\n/** Set or enable a specific feature */\nexport declare const LIBUSB_REQUEST_SET_FEATURE: number;\n/** Set device address for all future accesses */\nexport declare const LIBUSB_REQUEST_SET_ADDRESS: number;\n/** Get the specified descriptor */\nexport declare const LIBUSB_REQUEST_GET_DESCRIPTOR: number;\n/** Used to update existing descriptors or add new descriptors */\nexport declare const LIBUSB_REQUEST_SET_DESCRIPTOR: number;\n/** Get the current device configuration value */\nexport declare const LIBUSB_REQUEST_GET_CONFIGURATION: number;\n/** Set device configuration */\nexport declare const LIBUSB_REQUEST_SET_CONFIGURATION: number;\n/** Return the selected alternate setting for the specified interface */\nexport declare const LIBUSB_REQUEST_GET_INTERFACE: number;\n/** Select an alternate interface for the specified interface */\nexport declare const LIBUSB_REQUEST_SET_INTERFACE: number;\n/** Set then report an endpoint's synchronization frame */\nexport declare const LIBUSB_REQUEST_SYNCH_FRAME: number;\n\n// libusb_descriptor_type\n/** Device descriptor. See libusb_device_descriptor. */\nexport declare const LIBUSB_DT_DEVICE: number;\n/** Configuration descriptor. See libusb_config_descriptor. */\nexport declare const LIBUSB_DT_CONFIG: number;\n/** String descriptor */\nexport declare const LIBUSB_DT_STRING: number;\nexport declare const LIBUSB_DT_BOS: number;\n/** Interface descriptor. See libusb_interface_descriptor. */\nexport declare const LIBUSB_DT_INTERFACE: number;\n/** Endpoint descriptor. See libusb_endpoint_descriptor. */\nexport declare const LIBUSB_DT_ENDPOINT: number;\n/** HID descriptor */\nexport declare const LIBUSB_DT_HID: number;\n/** HID report descriptor */\nexport declare const LIBUSB_DT_REPORT: number;\n/** Physical descriptor */\nexport declare const LIBUSB_DT_PHYSICAL: number;\n/** Hub descriptor */\nexport declare const LIBUSB_DT_HUB: number;\n\n// libusb_endpoint_direction\n/** In: device-to-host */\nexport declare const LIBUSB_ENDPOINT_IN: number;\n/** Out: host-to-device */\nexport declare const LIBUSB_ENDPOINT_OUT: number;\n\n// libusb_transfer_type\n/** Control endpoint */\nexport declare const LIBUSB_TRANSFER_TYPE_CONTROL: number;\n/** Isochronous endpoint */\nexport declare const LIBUSB_TRANSFER_TYPE_ISOCHRONOUS: number;\n/** Bulk endpoint */\nexport declare const LIBUSB_TRANSFER_TYPE_BULK: number;\n/** Interrupt endpoint */\nexport declare const LIBUSB_TRANSFER_TYPE_INTERRUPT: number;\n\n// libusb_iso_sync_type\n/** No synchronization */\nexport declare const LIBUSB_ISO_SYNC_TYPE_NONE: number;\n/** Asynchronous */\nexport declare const LIBUSB_ISO_SYNC_TYPE_ASYNC: number;\n/** Adaptive */\nexport declare const LIBUSB_ISO_SYNC_TYPE_ADAPTIVE: number;\n/** Synchronous */\nexport declare const LIBUSB_ISO_SYNC_TYPE_SYNC: number;\n\n// libusb_iso_usage_type\n/** Data endpoint */\nexport declare const LIBUSB_ISO_USAGE_TYPE_DATA: number;\n/** Feedback endpoint */\nexport declare const LIBUSB_ISO_USAGE_TYPE_FEEDBACK: number;\n/** Implicit feedback Data endpoint */\nexport declare const LIBUSB_ISO_USAGE_TYPE_IMPLICIT: number;\n\n// libusb_transfer_status\n/**\n * Transfer completed without error. Note that this does not indicate\n * that the entire amount of requested data was transferred.\n */\nexport declare const LIBUSB_TRANSFER_COMPLETED: number;\n/** Transfer failed */\nexport declare const LIBUSB_TRANSFER_ERROR: number;\n/** Transfer timed out */\nexport declare const LIBUSB_TRANSFER_TIMED_OUT: number;\n/** Transfer was cancelled */\nexport declare const LIBUSB_TRANSFER_CANCELLED: number;\n/**\n * For bulk/interrupt endpoints: halt condition detected (endpoint\n * stalled). For control endpoints: control request not supported.\n */\nexport declare const LIBUSB_TRANSFER_STALL: number;\n/** Device was disconnected */\nexport declare const LIBUSB_TRANSFER_NO_DEVICE: number;\n/** Device sent more data than requested */\nexport declare const LIBUSB_TRANSFER_OVERFLOW: number;\n\n// libusb_transfer_flags\n/** Report short frames as errors */\nexport declare const LIBUSB_TRANSFER_SHORT_NOT_OK: number;\n/**\n * Automatically free() transfer buffer during libusb_free_transfer().\n * Note that buffers allocated with libusb_dev_mem_alloc() should not\n * be attempted freed in this way, since free() is not an appropriate\n * way to release such memory.\n */\nexport declare const LIBUSB_TRANSFER_FREE_BUFFER: number;\n/**\n * Automatically call libusb_free_transfer() after callback returns.\n * If this flag is set, it is illegal to call libusb_free_transfer()\n * from your transfer callback, as this will result in a double-free\n * when this flag is acted upon.\n */\nexport declare const LIBUSB_TRANSFER_FREE_TRANSFER: number;\n\n// libusb_request_type\n/** Standard */\nexport declare const LIBUSB_REQUEST_TYPE_STANDARD: number;\n/** Class */\nexport declare const LIBUSB_REQUEST_TYPE_CLASS: number;\n/** Vendor */\nexport declare const LIBUSB_REQUEST_TYPE_VENDOR: number;\n/** Reserved */\nexport declare const LIBUSB_REQUEST_TYPE_RESERVED: number;\n\n// libusb_request_recipient\n/** Device */\nexport declare const LIBUSB_RECIPIENT_DEVICE: number;\n/** Interface */\nexport declare const LIBUSB_RECIPIENT_INTERFACE: number;\n/** Endpoint */\nexport declare const LIBUSB_RECIPIENT_ENDPOINT: number;\n/** Other */\nexport declare const LIBUSB_RECIPIENT_OTHER: number;\n\nexport declare const LIBUSB_CONTROL_SETUP_SIZE: number;\nexport declare const LIBUSB_DT_BOS_SIZE: number;\n\n// libusb_capability\nexport declare const LIBUSB_CAP_HAS_CAPABILITY: number;\nexport declare const LIBUSB_CAP_HAS_HOTPLUG: number;\nexport declare const LIBUSB_CAP_HAS_HID_ACCESS: number;\nexport declare const LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER: number;\n\n// libusb_error\n/** Input/output error */\nexport declare const LIBUSB_ERROR_IO: number;\n/** Invalid parameter */\nexport declare const LIBUSB_ERROR_INVALID_PARAM: number;\n/** Access denied (insufficient permissions) */\nexport declare const LIBUSB_ERROR_ACCESS: number;\n/** No such device (it may have been disconnected) */\nexport declare const LIBUSB_ERROR_NO_DEVICE: number;\n/** Entity not found */\nexport declare const LIBUSB_ERROR_NOT_FOUND: number;\n/** Resource busy */\nexport declare const LIBUSB_ERROR_BUSY: number;\n/** Operation timed out */\nexport declare const LIBUSB_ERROR_TIMEOUT: number;\n/** Overflow */\nexport declare const LIBUSB_ERROR_OVERFLOW: number;\n/** Pipe error */\nexport declare const LIBUSB_ERROR_PIPE: number;\n/** System call interrupted (perhaps due to signal) */\nexport declare const LIBUSB_ERROR_INTERRUPTED: number;\n/** Insufficient memory */\nexport declare const LIBUSB_ERROR_NO_MEM: number;\n/** Operation not supported or unimplemented on this platform */\nexport declare const LIBUSB_ERROR_NOT_SUPPORTED: number;\n/** Other error */\nexport declare const LIBUSB_ERROR_OTHER: number;\n"]},"metadata":{},"sourceType":"script"}