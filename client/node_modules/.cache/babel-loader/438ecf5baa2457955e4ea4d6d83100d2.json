{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtendedDevice = void 0;\n\nvar usb = require(\"./bindings\");\n\nvar interface_1 = require(\"./interface\");\n\nvar capability_1 = require(\"./capability\");\n\nvar isBuffer = function (obj) {\n  return !!obj && obj instanceof Uint8Array;\n};\n\nvar DEFAULT_TIMEOUT = 1000;\n\nvar ExtendedDevice =\n/** @class */\nfunction () {\n  function ExtendedDevice() {\n    this._timeout = DEFAULT_TIMEOUT;\n  }\n\n  Object.defineProperty(ExtendedDevice.prototype, \"timeout\", {\n    /**\n     * Timeout in milliseconds to use for control transfers.\n     */\n    get: function () {\n      return this._timeout || DEFAULT_TIMEOUT;\n    },\n    set: function (value) {\n      this._timeout = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExtendedDevice.prototype, \"configDescriptor\", {\n    /**\n     * Object with properties for the fields of the active configuration descriptor.\n     */\n    get: function () {\n      try {\n        return this.__getConfigDescriptor();\n      } catch (e) {\n        // Check descriptor exists\n        if (e.errno === usb.LIBUSB_ERROR_NOT_FOUND) {\n          return undefined;\n        }\n\n        throw e;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExtendedDevice.prototype, \"allConfigDescriptors\", {\n    /**\n     * Contains all config descriptors of the device (same structure as .configDescriptor above)\n     */\n    get: function () {\n      try {\n        return this.__getAllConfigDescriptors();\n      } catch (e) {\n        // Check descriptors exist\n        if (e.errno === usb.LIBUSB_ERROR_NOT_FOUND) {\n          return [];\n        }\n\n        throw e;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExtendedDevice.prototype, \"parent\", {\n    /**\n     * Contains the parent of the device, such as a hub. If there is no parent this property is set to `null`.\n     */\n    get: function () {\n      return this.__getParent();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Open the device.\n   * @param defaultConfig\n   */\n\n  ExtendedDevice.prototype.open = function (defaultConfig) {\n    if (defaultConfig === void 0) {\n      defaultConfig = true;\n    }\n\n    this.__open();\n\n    if (defaultConfig === false) {\n      return;\n    }\n\n    this.interfaces = [];\n    var len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;\n\n    for (var i = 0; i < len; i++) {\n      this.interfaces[i] = new interface_1.Interface(this, i);\n    }\n  };\n  /**\n   * Close the device.\n   *\n   * The device must be open to use this method.\n   */\n\n\n  ExtendedDevice.prototype.close = function () {\n    this.__close();\n\n    this.interfaces = undefined;\n  };\n  /**\n   * Set the device configuration to something other than the default (0). To use this, first call `.open(false)` (which tells it not to auto configure),\n   * then before claiming an interface, call this method.\n   *\n   * The device must be open to use this method.\n   * @param desired\n   * @param callback\n   */\n\n\n  ExtendedDevice.prototype.setConfiguration = function (desired, callback) {\n    var _this = this;\n\n    this.__setConfiguration(desired, function (error) {\n      if (!error) {\n        _this.interfaces = [];\n        var len = _this.configDescriptor ? _this.configDescriptor.interfaces.length : 0;\n\n        for (var i = 0; i < len; i++) {\n          _this.interfaces[i] = new interface_1.Interface(_this, i);\n        }\n      }\n\n      if (callback) {\n        callback.call(_this, error);\n      }\n    });\n  };\n  /**\n   * Perform a control transfer with `libusb_control_transfer`.\n   *\n   * Parameter `data_or_length` can be an integer length for an IN transfer, or a `Buffer` for an OUT transfer. The type must match the direction specified in the MSB of bmRequestType.\n   *\n   * The `data` parameter of the callback is actual transferred for OUT transfers, or will be passed a Buffer for IN transfers.\n   *\n   * The device must be open to use this method.\n   * @param bmRequestType\n   * @param bRequest\n   * @param wValue\n   * @param wIndex\n   * @param data_or_length\n   * @param callback\n   */\n\n\n  ExtendedDevice.prototype.controlTransfer = function (bmRequestType, bRequest, wValue, wIndex, data_or_length, callback) {\n    var _this = this;\n\n    var isIn = !!(bmRequestType & usb.LIBUSB_ENDPOINT_IN);\n    var wLength = isIn ? data_or_length : data_or_length.length;\n\n    if (isIn) {\n      if (!(data_or_length >= 0)) {\n        throw new TypeError('Expected size number for IN transfer (based on bmRequestType)');\n      }\n    } else {\n      if (!isBuffer(data_or_length)) {\n        throw new TypeError('Expected buffer for OUT transfer (based on bmRequestType)');\n      }\n    } // Buffer for the setup packet\n    // http://libusbx.sourceforge.net/api-1.0/structlibusb__control__setup.html\n\n\n    var buf = Buffer.alloc(wLength + usb.LIBUSB_CONTROL_SETUP_SIZE);\n    buf.writeUInt8(bmRequestType, 0);\n    buf.writeUInt8(bRequest, 1);\n    buf.writeUInt16LE(wValue, 2);\n    buf.writeUInt16LE(wIndex, 4);\n    buf.writeUInt16LE(wLength, 6);\n\n    if (!isIn) {\n      buf.set(data_or_length, usb.LIBUSB_CONTROL_SETUP_SIZE);\n    }\n\n    var transfer = new usb.Transfer(this, 0, usb.LIBUSB_TRANSFER_TYPE_CONTROL, this.timeout, function (error, buf, actual) {\n      if (callback) {\n        if (isIn) {\n          callback.call(_this, error, buf.slice(usb.LIBUSB_CONTROL_SETUP_SIZE, usb.LIBUSB_CONTROL_SETUP_SIZE + actual));\n        } else {\n          callback.call(_this, error, actual);\n        }\n      }\n    });\n\n    try {\n      transfer.submit(buf);\n    } catch (e) {\n      if (callback) {\n        process.nextTick(function () {\n          return callback.call(_this, e, undefined);\n        });\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Return the interface with the specified interface number.\n   *\n   * The device must be open to use this method.\n   * @param addr\n   */\n\n\n  ExtendedDevice.prototype.interface = function (addr) {\n    if (!this.interfaces) {\n      throw new Error('Device must be open before searching for interfaces');\n    }\n\n    addr = addr || 0;\n\n    for (var i = 0; i < this.interfaces.length; i++) {\n      if (this.interfaces[i].interfaceNumber === addr) {\n        return this.interfaces[i];\n      }\n    }\n\n    throw new Error(\"Interface not found for address: \" + addr);\n  };\n  /**\n   * Perform a control transfer to retrieve a string descriptor\n   *\n   * The device must be open to use this method.\n   * @param desc_index\n   * @param callback\n   */\n\n\n  ExtendedDevice.prototype.getStringDescriptor = function (desc_index, callback) {\n    // Index 0 indicates null\n    if (desc_index === 0) {\n      callback();\n      return;\n    }\n\n    var langid = 0x0409;\n    var length = 255;\n    this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_STRING << 8 | desc_index, langid, length, function (error, buffer) {\n      if (error) {\n        return callback(error);\n      }\n\n      callback(undefined, isBuffer(buffer) ? buffer.toString('utf16le', 2) : undefined);\n    });\n  };\n  /**\n   * Perform a control transfer to retrieve an object with properties for the fields of the Binary Object Store descriptor.\n   *\n   * The device must be open to use this method.\n   * @param callback\n   */\n\n\n  ExtendedDevice.prototype.getBosDescriptor = function (callback) {\n    var _this = this;\n\n    if (this._bosDescriptor) {\n      // Cached descriptor\n      return callback(undefined, this._bosDescriptor);\n    }\n\n    if (this.deviceDescriptor.bcdUSB < 0x201) {\n      // BOS is only supported from USB 2.0.1\n      return callback(undefined, undefined);\n    }\n\n    this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, usb.LIBUSB_DT_BOS_SIZE, function (error, buffer) {\n      if (error) {\n        // Check BOS descriptor exists\n        if (error.errno === usb.LIBUSB_TRANSFER_STALL) return callback(undefined, undefined);\n        return callback(error, undefined);\n      }\n\n      if (!isBuffer(buffer)) {\n        return callback(undefined, undefined);\n      }\n\n      var totalLength = buffer.readUInt16LE(2);\n\n      _this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, totalLength, function (error, buffer) {\n        if (error) {\n          // Check BOS descriptor exists\n          if (error.errno === usb.LIBUSB_TRANSFER_STALL) return callback(undefined, undefined);\n          return callback(error, undefined);\n        }\n\n        if (!isBuffer(buffer)) {\n          return callback(undefined, undefined);\n        }\n\n        var descriptor = {\n          bLength: buffer.readUInt8(0),\n          bDescriptorType: buffer.readUInt8(1),\n          wTotalLength: buffer.readUInt16LE(2),\n          bNumDeviceCaps: buffer.readUInt8(4),\n          capabilities: []\n        };\n        var i = usb.LIBUSB_DT_BOS_SIZE;\n\n        while (i < descriptor.wTotalLength) {\n          var capability = {\n            bLength: buffer.readUInt8(i + 0),\n            bDescriptorType: buffer.readUInt8(i + 1),\n            bDevCapabilityType: buffer.readUInt8(i + 2),\n            dev_capability_data: buffer.slice(i + 3, i + buffer.readUInt8(i + 0))\n          };\n          descriptor.capabilities.push(capability);\n          i += capability.bLength;\n        } // Cache descriptor\n\n\n        _this._bosDescriptor = descriptor;\n        callback(undefined, _this._bosDescriptor);\n      });\n    });\n  };\n  /**\n   * Retrieve a list of Capability objects for the Binary Object Store capabilities of the device.\n   *\n   * The device must be open to use this method.\n   * @param callback\n   */\n\n\n  ExtendedDevice.prototype.getCapabilities = function (callback) {\n    var _this = this;\n\n    var capabilities = [];\n    this.getBosDescriptor(function (error, descriptor) {\n      if (error) return callback(error, undefined);\n      var len = descriptor ? descriptor.capabilities.length : 0;\n\n      for (var i = 0; i < len; i++) {\n        capabilities.push(new capability_1.Capability(_this, i));\n      }\n\n      callback(undefined, capabilities);\n    });\n  };\n\n  return ExtendedDevice;\n}();\n\nexports.ExtendedDevice = ExtendedDevice;","map":{"version":3,"mappings":"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","names":["isBuffer","obj","Uint8Array","DEFAULT_TIMEOUT","Object","ExtendedDevice","_timeout","value","__getConfigDescriptor","e","errno","usb","LIBUSB_ERROR_NOT_FOUND","undefined","__getAllConfigDescriptors","__getParent","defaultConfig","__open","interfaces","len","configDescriptor","length","i","interface_1","__close","desired","callback","__setConfiguration","error","_this","call","bmRequestType","bRequest","wValue","wIndex","data_or_length","isIn","LIBUSB_ENDPOINT_IN","wLength","TypeError","buf","Buffer","alloc","LIBUSB_CONTROL_SETUP_SIZE","writeUInt8","writeUInt16LE","set","transfer","Transfer","LIBUSB_TRANSFER_TYPE_CONTROL","timeout","actual","slice","submit","process","nextTick","addr","Error","interfaceNumber","desc_index","langid","controlTransfer","LIBUSB_REQUEST_GET_DESCRIPTOR","LIBUSB_DT_STRING","buffer","toString","_bosDescriptor","deviceDescriptor","bcdUSB","LIBUSB_DT_BOS","LIBUSB_DT_BOS_SIZE","LIBUSB_TRANSFER_STALL","totalLength","readUInt16LE","descriptor","bLength","readUInt8","bDescriptorType","wTotalLength","bNumDeviceCaps","capabilities","capability","bDevCapabilityType","dev_capability_data","push","getBosDescriptor","capability_1","exports"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\usb\\device.ts"],"sourcesContent":["import * as usb from './bindings';\nimport { Interface } from './interface';\nimport { Capability } from './capability';\nimport { BosDescriptor, ConfigDescriptor } from './descriptors';\n\nconst isBuffer = (obj: number | Uint8Array | undefined): obj is Uint8Array => !!obj && obj instanceof Uint8Array;\nconst DEFAULT_TIMEOUT = 1000;\n\nexport class ExtendedDevice {\n    /**\n     * List of Interface objects for the interfaces of the default configuration of the device.\n     */\n    public interfaces: Interface[] | undefined;\n\n    private _timeout = DEFAULT_TIMEOUT;\n    /**\n     * Timeout in milliseconds to use for control transfers.\n     */\n    public get timeout(): number {\n        return this._timeout || DEFAULT_TIMEOUT;\n    }\n    public set timeout(value: number) {\n        this._timeout = value;\n    }\n\n    /**\n     * Object with properties for the fields of the active configuration descriptor.\n     */\n    public get configDescriptor(): ConfigDescriptor | undefined {\n        try {\n            return (this as unknown as usb.Device).__getConfigDescriptor();\n        } catch (e) {\n            // Check descriptor exists\n            if (e.errno === usb.LIBUSB_ERROR_NOT_FOUND) {\n                return undefined;\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Contains all config descriptors of the device (same structure as .configDescriptor above)\n     */\n    public get allConfigDescriptors(): ConfigDescriptor[] {\n        try {\n            return (this as unknown as usb.Device).__getAllConfigDescriptors();\n        } catch (e) {\n            // Check descriptors exist\n            if (e.errno === usb.LIBUSB_ERROR_NOT_FOUND) {\n                return [];\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Contains the parent of the device, such as a hub. If there is no parent this property is set to `null`.\n     */\n    public get parent(): usb.Device {\n        return (this as unknown as usb.Device).__getParent();\n    }\n\n    /**\n     * Open the device.\n     * @param defaultConfig\n     */\n    public open(this: usb.Device, defaultConfig = true): void {\n        this.__open();\n        if (defaultConfig === false) {\n            return;\n        }\n        this.interfaces = [];\n        const len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;\n        for (let i = 0; i < len; i++) {\n            this.interfaces[i] = new Interface(this, i);\n        }\n    }\n\n    /**\n     * Close the device.\n     *\n     * The device must be open to use this method.\n     */\n    public close(this: usb.Device): void {\n        this.__close();\n        this.interfaces = undefined;\n    }\n\n    /**\n     * Set the device configuration to something other than the default (0). To use this, first call `.open(false)` (which tells it not to auto configure),\n     * then before claiming an interface, call this method.\n     *\n     * The device must be open to use this method.\n     * @param desired\n     * @param callback\n     */\n    public setConfiguration(this: usb.Device, desired: number, callback?: (error: usb.LibUSBException | undefined) => void): void {\n        this.__setConfiguration(desired, error => {\n            if (!error) {\n                this.interfaces = [];\n                const len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;\n                for (let i = 0; i < len; i++) {\n                    this.interfaces[i] = new Interface(this, i);\n                }\n            }\n            if (callback) {\n                callback.call(this, error);\n            }\n        });\n    }\n\n    /**\n     * Perform a control transfer with `libusb_control_transfer`.\n     *\n     * Parameter `data_or_length` can be an integer length for an IN transfer, or a `Buffer` for an OUT transfer. The type must match the direction specified in the MSB of bmRequestType.\n     *\n     * The `data` parameter of the callback is actual transferred for OUT transfers, or will be passed a Buffer for IN transfers.\n     *\n     * The device must be open to use this method.\n     * @param bmRequestType\n     * @param bRequest\n     * @param wValue\n     * @param wIndex\n     * @param data_or_length\n     * @param callback\n     */\n    public controlTransfer(this: usb.Device, bmRequestType: number, bRequest: number, wValue: number, wIndex: number, data_or_length: number | Buffer,\n        callback?: (error: usb.LibUSBException | undefined, buffer: Buffer | number | undefined) => void): usb.Device {\n        const isIn = !!(bmRequestType & usb.LIBUSB_ENDPOINT_IN);\n        const wLength = isIn ? data_or_length as number : (data_or_length as Buffer).length;\n\n        if (isIn) {\n            if (!(data_or_length >= 0)) {\n                throw new TypeError('Expected size number for IN transfer (based on bmRequestType)');\n            }\n        } else {\n            if (!isBuffer(data_or_length)) {\n                throw new TypeError('Expected buffer for OUT transfer (based on bmRequestType)');\n            }\n        }\n\n        // Buffer for the setup packet\n        // http://libusbx.sourceforge.net/api-1.0/structlibusb__control__setup.html\n        const buf = Buffer.alloc(wLength + usb.LIBUSB_CONTROL_SETUP_SIZE);\n        buf.writeUInt8(bmRequestType, 0);\n        buf.writeUInt8(bRequest, 1);\n        buf.writeUInt16LE(wValue, 2);\n        buf.writeUInt16LE(wIndex, 4);\n        buf.writeUInt16LE(wLength, 6);\n\n        if (!isIn) {\n            buf.set(data_or_length as Buffer, usb.LIBUSB_CONTROL_SETUP_SIZE);\n        }\n\n        const transfer = new usb.Transfer(this, 0, usb.LIBUSB_TRANSFER_TYPE_CONTROL, this.timeout,\n            (error, buf, actual) => {\n                if (callback) {\n                    if (isIn) {\n                        callback.call(this, error, buf.slice(usb.LIBUSB_CONTROL_SETUP_SIZE, usb.LIBUSB_CONTROL_SETUP_SIZE + actual));\n                    } else {\n                        callback.call(this, error, actual);\n                    }\n                }\n            }\n        );\n\n        try {\n            transfer.submit(buf);\n        } catch (e) {\n            if (callback) {\n                process.nextTick(() => callback.call(this, e, undefined));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Return the interface with the specified interface number.\n     *\n     * The device must be open to use this method.\n     * @param addr\n     */\n    public interface(this: usb.Device, addr: number): Interface {\n        if (!this.interfaces) {\n            throw new Error('Device must be open before searching for interfaces');\n        }\n\n        addr = addr || 0;\n        for (let i = 0; i < this.interfaces.length; i++) {\n            if (this.interfaces[i].interfaceNumber === addr) {\n                return this.interfaces[i];\n            }\n        }\n\n        throw new Error(`Interface not found for address: ${addr}`);\n    }\n\n    /**\n     * Perform a control transfer to retrieve a string descriptor\n     *\n     * The device must be open to use this method.\n     * @param desc_index\n     * @param callback\n     */\n    public getStringDescriptor(this: usb.Device, desc_index: number, callback: (error?: usb.LibUSBException, value?: string) => void): void {\n        // Index 0 indicates null\n        if (desc_index === 0) {\n            callback();\n            return;\n        }\n\n        const langid = 0x0409;\n        const length = 255;\n        this.controlTransfer(\n            usb.LIBUSB_ENDPOINT_IN,\n            usb.LIBUSB_REQUEST_GET_DESCRIPTOR,\n            ((usb.LIBUSB_DT_STRING << 8) | desc_index),\n            langid,\n            length,\n            (error, buffer) => {\n                if (error) {\n                    return callback(error);\n                }\n                callback(undefined, isBuffer(buffer) ? buffer.toString('utf16le', 2) : undefined);\n            }\n        );\n    }\n\n    /**\n     * Perform a control transfer to retrieve an object with properties for the fields of the Binary Object Store descriptor.\n     *\n     * The device must be open to use this method.\n     * @param callback\n     */\n    public getBosDescriptor(this: usb.Device, callback: (error?: usb.LibUSBException, descriptor?: BosDescriptor) => void): void {\n        if (this._bosDescriptor) {\n            // Cached descriptor\n            return callback(undefined, this._bosDescriptor);\n        }\n\n        if (this.deviceDescriptor.bcdUSB < 0x201) {\n            // BOS is only supported from USB 2.0.1\n            return callback(undefined, undefined);\n        }\n\n        this.controlTransfer(\n            usb.LIBUSB_ENDPOINT_IN,\n            usb.LIBUSB_REQUEST_GET_DESCRIPTOR,\n            (usb.LIBUSB_DT_BOS << 8),\n            0,\n            usb.LIBUSB_DT_BOS_SIZE,\n            (error, buffer) => {\n                if (error) {\n                    // Check BOS descriptor exists\n                    if (error.errno === usb.LIBUSB_TRANSFER_STALL) return callback(undefined, undefined);\n                    return callback(error, undefined);\n                }\n\n                if (!isBuffer(buffer)) {\n                    return callback(undefined, undefined);\n                }\n\n                const totalLength = buffer.readUInt16LE(2);\n                this.controlTransfer(\n                    usb.LIBUSB_ENDPOINT_IN,\n                    usb.LIBUSB_REQUEST_GET_DESCRIPTOR,\n                    (usb.LIBUSB_DT_BOS << 8),\n                    0,\n                    totalLength,\n                    (error, buffer) => {\n                        if (error) {\n                            // Check BOS descriptor exists\n                            if (error.errno === usb.LIBUSB_TRANSFER_STALL) return callback(undefined, undefined);\n                            return callback(error, undefined);\n                        }\n\n                        if (!isBuffer(buffer)) {\n                            return callback(undefined, undefined);\n                        }\n\n                        const descriptor: BosDescriptor = {\n                            bLength: buffer.readUInt8(0),\n                            bDescriptorType: buffer.readUInt8(1),\n                            wTotalLength: buffer.readUInt16LE(2),\n                            bNumDeviceCaps: buffer.readUInt8(4),\n                            capabilities: []\n                        };\n\n                        let i = usb.LIBUSB_DT_BOS_SIZE;\n                        while (i < descriptor.wTotalLength) {\n                            const capability = {\n                                bLength: buffer.readUInt8(i + 0),\n                                bDescriptorType: buffer.readUInt8(i + 1),\n                                bDevCapabilityType: buffer.readUInt8(i + 2),\n                                dev_capability_data: buffer.slice(i + 3, i + buffer.readUInt8(i + 0))\n                            };\n\n                            descriptor.capabilities.push(capability);\n                            i += capability.bLength;\n                        }\n\n                        // Cache descriptor\n                        this._bosDescriptor = descriptor;\n                        callback(undefined, this._bosDescriptor);\n                    }\n                );\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Capability objects for the Binary Object Store capabilities of the device.\n     *\n     * The device must be open to use this method.\n     * @param callback\n     */\n    public getCapabilities(this: usb.Device, callback: (error: usb.LibUSBException | undefined, capabilities?: Capability[]) => void): void {\n        const capabilities: Capability[] = [];\n\n        this.getBosDescriptor((error, descriptor) => {\n            if (error) return callback(error, undefined);\n\n            const len = descriptor ? descriptor.capabilities.length : 0;\n            for (let i = 0; i < len; i++) {\n                capabilities.push(new Capability(this, i));\n            }\n\n            callback(undefined, capabilities);\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"script"}