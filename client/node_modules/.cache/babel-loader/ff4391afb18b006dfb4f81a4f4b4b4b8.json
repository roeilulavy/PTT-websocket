{"ast":null,"code":"/*\n  SFMediaStream\n  HTML5 media streamer library for playing music, video, playlist,\n  or even live streaming microphone & camera with node server\n\n  https://github.com/ScarletsFiction/SFMediaStream\n*/\nfunction _typeof(e) {\n  return (_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n    return typeof e;\n  } : function (e) {\n    return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  })(e);\n}\n\n!function (e, n) {\n  \"object\" === (\"undefined\" == typeof exports ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module ? (module.exports = {}, n(module.exports, window, !0)) : n(e, window);\n}(this || window, function (e, n, t) {\n  \"use strict\";\n\n  var o = {\n    audioContext: !1,\n    getElementAudioNode: function (e) {\n      return e.crossOrigin = \"anonymous\", this.audioContext.createMediaElementSource(e);\n    },\n    getElementVideoNode: function (e) {\n      return e.crossOrigin = \"anonymous\", null;\n    }\n  },\n      r = {},\n      a = {\n    webm: [\"opus\", \"vorbis\"],\n    mp4: [\"mp4a.67\", \"mp4a.40.29\", \"mp4a.40.5\", \"mp4a.40.2\", \"mp3\"],\n    ogg: [\"opus\", \"vorbis\"]\n  },\n      i = {\n    webm: [\"vp8,opus\", \"vp8,vorbis\"],\n    mp4: [\"mp4v.20.8,mp4a.40.2\", \"mp4v.20.240,mp4a.40.2\", \"avc1.42E01E,mp4a.40.2\", \"avc1.58A01E,mp4a.40.2\", \"avc1.64001E,mp4a.40.2\"],\n    \"3gpp\": [\"mp4v.20.8,samr\"],\n    ogg: [\"dirac,vorbis\", \"theora,vorbis\"]\n  },\n      c = [],\n      u = !1;\n  !function () {\n    var e = n.AudioContext || n.webkitAudioContext;\n    if (!e) return console.error(\"`AudioContext` was not available\");\n    o.audioContext = new e();\n\n    var t = function (e) {\n      var n = o.audioContext.createBuffer(1, 1, 22050),\n          t = o.audioContext.createBufferSource();\n      t.buffer = n, t.connect(o.audioContext.destination), t.onended = function () {\n        t.disconnect(0), t = n = null, r();\n      }, t.start ? t.start(0) : t.noteOn(0), o.audioContext.resume();\n    };\n\n    function r() {\n      document.removeEventListener(\"touchstart\", t, !0), document.removeEventListener(\"touchend\", t, !0), document.removeEventListener(\"click\", t, !0);\n\n      for (var e = 0; e < c.length; e++) c[e]();\n\n      c.length = 0;\n    }\n\n    document.addEventListener(\"touchstart\", t, !0), document.addEventListener(\"touchend\", t, !0), document.addEventListener(\"click\", t, !0);\n  }();\n\n  var d = function (e) {\n    e || (e = 1e3);\n    var n = e / 1e3,\n        t = this;\n    t.debug = !1, t.playing = !1, t.latency = 0, t.mimeType = null, t.bufferElement = [], t.onStop = null, t.audioContext = o.audioContext, t.outputNode = !1;\n    var r = !0,\n        a = !1,\n        i = !1,\n        c = t.element = new Audio(),\n        u = t.audioContext.createMediaElementSource(c);\n    c.addEventListener(\"error\", function (e) {\n      console.error(e.target.error);\n    }), t.connect = function (e) {\n      !0 === r && (r = !1, u.disconnect()), t.outputNode = t.audioContext.createGain(), t.outputNode.connect(e), u.connect(e);\n    }, t.disconnect = function (e) {\n      t.outputNode.disconnect(e), r = !0, u.disconnect(e), u.connect(t.audioContext.destination);\n    }, t.stop = function () {\n      i.stop(), t.playing = !1, t.buffering = !1, t.onStop && t.onStop();\n    }, t.setBufferHeader = function (n) {\n      if (n.data) {\n        var o = n.data;\n        t.mimeType = n.mimeType, !1 !== i ? i.stop() : u.connect(t.audioContext.destination), i = new s(t.mimeType, e, o), a = new Uint8Array(o), c.src = t.objectURL = i.objectURL, t.audioContext.decodeAudioData(o.slice(0), function (e) {\n          d = e.getChannelData(0).length;\n        });\n      } else a = !1;\n    };\n    var d = 0;\n\n    function l(e, n) {\n      var o;\n      return t.bufferElement[e] = ((o = t.audioContext.createBufferSource()).onended = function () {\n        this.stop(), this.disconnect();\n      }, o), !1 !== (n = function (e) {\n        var n = e.getChannelData(0).length - d;\n        if (0 === n) return !1;\n\n        for (var o = e.numberOfChannels, r = t.audioContext.createBuffer(o, n, e.sampleRate), a = 0; a < o; a++) r.getChannelData(a).set(e.getChannelData(a).subarray(d));\n\n        return r;\n      }(n)) && (t.bufferElement[e].buffer = n, t.outputNode && t.outputNode.context && !1 === r ? t.bufferElement[e].connect(t.outputNode) : t.bufferElement[e].connect(t.audioContext.destination), !0);\n    }\n\n    t.playStream = function () {\n      t.playing = !0;\n    };\n\n    var f = 0;\n    t.realtimeBufferPlay = function (e) {\n      if (!1 !== t.playing) {\n        var o = e[0],\n            r = e[1];\n\n        if (t.debug && console.log(\"Receiving data\", o.byteLength), 0 !== o.byteLength) {\n          t.latency = Number(String(Date.now()).slice(-5, -3)) - r + n + t.audioContext.baseLatency;\n          var i = f;\n          ++f > 2 && (f = 0), t.audioContext.decodeAudioData(function (e) {\n            var n = new Uint8Array(a.byteLength + e.byteLength);\n            return n.set(a, 0), n.set(new Uint8Array(e), a.byteLength), n.buffer;\n          }(o), function (e) {\n            !1 !== l(i, e) && t.bufferElement[i].start(0);\n          });\n        }\n      }\n    }, t.receiveBuffer = function (e) {\n      if (!1 !== t.playing && i.append) {\n        var o = e[0],\n            r = e[1];\n        i.append(o), c.paused && c.play(), t.latency = Number(String(Date.now()).slice(-5, -3)) - r + t.audioContext.baseLatency + n, t.debug && console.log(\"Total latency: \" + t.latency);\n      }\n    };\n  },\n      l = {\n    \"audio/webm;codecs=opus\": \"GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwH/////////FUmpZpkq17GDD0JATYCGQ2hyb21lV0GGQ2hyb21lFlSua7+uvdeBAXPFh7o5nyc1kHqDgQKGhkFfT1BVU2Oik09wdXNIZWFkAQIAAIC7AAAAAADhjbWERzuAAJ+BAmJkgSAfQ7Z1Af/////////ngQCjjIEAAID/A//+//7//qM=\"\n  };\n\n  o.convert = {\n    midiToFreq: function (e) {\n      return e <= -1500 ? 0 : e > 1499 ? 3.282417553401589e38 : 440 * Math.pow(2, (Math.floor(e) - 69) / 12);\n    },\n    freqToMidi: function (e) {\n      return e > 0 ? Math.floor(Math.log(e / 440) / Math.LN2 * 12 + 69) : -1500;\n    },\n    powerToDb: function (e) {\n      if (e <= 0) return 0;\n      var n = 100 + 10 / Math.LN10 * Math.log(e);\n      return n < 0 ? 0 : n;\n    },\n    dbToPower: function (e) {\n      return e <= 0 ? 0 : (e > 870 && (e = 870), Math.exp(.1 * Math.LN10 * (e - 100)));\n    },\n    ampToDb: function (e) {\n      return 20 * (e > 1e-5 ? Math.log(e) / Math.LN10 : -5);\n    },\n    dbToAmp: function (e) {\n      return Math.pow(10, e / 20);\n    },\n    velToAmp: function (e) {\n      return e / 127;\n    }\n  };\n\n  var s = function (e, n, t) {\n    var o = this;\n    o.source = new MediaSource(), o.objectURL = URL.createObjectURL(o.source);\n    var r = !1,\n        a = 0,\n        i = null,\n        c = [];\n\n    function u(e) {\n      i.appendBuffer(e), a += n;\n    }\n\n    o.source.onsourceopen = function () {\n      (i = o.source.addSourceBuffer(e)).mode = \"sequence\", i.appendBuffer(t), i.onerror = function (e) {\n        console.error(\"SourceBuffer error:\", e);\n      }, i.onupdateend = function () {\n        if (r) return r = !1, a = 1e4, void i.remove(0, 10);\n        i.updating || 0 === c.length || u(c.shift());\n      };\n    }, o.source.onerror = function (e) {\n      console.error(\"MediaSource error:\", e);\n    }, o.append = function (e) {\n      return null !== i && (i.updating || 2 !== i.buffered.length || console.log(\"something wrong\"), a >= 2e4 && (r = !0), i.updating ? c.push(e) : u(e), a / 1e3);\n    }, o.stop = function () {\n      i.updating && i.abort(), \"open\" === o.source.readyState && o.source.endOfStream();\n    };\n  },\n      f = function (e) {\n    var n = this;\n\n    if (void 0 === e && (e = \"audio\"), e.constructor === String) {\n      if (\"audio\" !== e && \"video\" !== e) return console.error('Supported player is \"audio\" or \"video\"');\n      e = document.createElement(e), document.body.appendChild(e);\n    }\n\n    var t = [\"autoplay\", \"loop\", \"buffered\", \"buffered\", \"controller\", \"currentTime\", \"currentSrc\", \"duration\", \"ended\", \"error\", \"readyState\", \"networkState\", \"paused\", \"played\", \"seekable\", \"seeking\"],\n        r = !1;\n\n    if (Object.defineProperty(n, \"audioOutput\", {\n      get: function () {\n        return r || (r = o.getElementAudioNode(e)), r;\n      },\n      enumerable: !0\n    }), \"video\" === e.tagName.toLowerCase()) {\n      t = t.concat([\"poster\", \"height\", \"width\"]);\n      var a = !1;\n      Object.defineProperty(n, \"videoOutput\", {\n        get: function () {\n          return a || (a = o.getElementVideoNode(e)), a;\n        },\n        enumerable: !0\n      });\n    }\n\n    n.load = function () {\n      e.load();\n    }, n.canPlayType = function () {\n      e.canPlayType();\n    };\n\n    for (var i = 0; i < t.length; i++) o.extra.objectPropertyLinker(n, e, t[i]);\n\n    n.preload = !0, e.preload = \"metadata\", e.crossorigin = \"anonymous\", n.audioFadeEffect = !0, n.speed = function (n) {\n      if (void 0 === n) return e.defaultPlaybackRate;\n      e.defaultPlaybackRate = e.playbackRate = n;\n    }, n.mute = function (n) {\n      if (void 0 === n) return e.muted;\n      e.defaultMuted = e.muted = n;\n    }, n.stop = function () {\n      n.pause(), n.currentTime = 0;\n    };\n    var d = 1;\n\n    n.volume = function (n) {\n      if (void 0 === n) return d;\n      e.volume = d = n;\n    };\n\n    var l = !1;\n\n    function s(n, t) {\n      e.play().then(function () {\n        l = !1, n && n();\n      }).catch(function (e) {\n        if (t) t(e);else {\n          if (!1 === u) return void (!1 === l && c.push(function () {\n            s(n, t);\n          }));\n          console.error(e);\n        }\n      });\n    }\n\n    n.play = function (t, r) {\n      if (e.paused) return n.audioFadeEffect ? (e.volume = 0, s(t, r), void o.extra.fadeNumber(0, d, .02, 400, function (n) {\n        e.volume = n;\n      }, t)) : void s(t, r);\n      t && t();\n    }, n.pause = function (t) {\n      e.paused ? t && t() : n.audioFadeEffect ? o.extra.fadeNumber(d, 0, -.02, 400, function (n) {\n        e.volume = n;\n      }, function () {\n        e.pause(), t && t();\n      }) : (e.pause(), t && t());\n    }, n.prepare = function (t, o, r) {\n      if (!r && !e.paused) return n.pause(function () {\n        n.prepare(t, o, !0);\n      });\n\n      for (var a = e.querySelectorAll(\"source\"), i = a.length - 1; i >= 0; i--) a[i].remove();\n\n      if (n.preload && o && (n.once(\"canplay\", o), n.once(\"error\", function () {\n        n.off(\"canplay\", o);\n      })), \"string\" == typeof t) e.insertAdjacentHTML(\"beforeend\", '<source src=\"'.concat(t.split('\"').join('\\\\\"'), '\"/>'));else {\n        a = \"\";\n\n        for (i = 0; i < t.length; i++) a += '<source src=\"'.concat(t[i].split('\"').join('\\\\\"'), '\"/>');\n\n        e.insertAdjacentHTML(\"beforeend\", a);\n      }\n      n.preload ? e.load() : o && o();\n    };\n    var f = {};\n\n    function v(e) {\n      for (var t = 0; t < f[e.type].length; t++) f[e.type][t](e, n);\n    }\n\n    n.on = function (t, o) {\n      var r = t.toLowerCase();\n      return void 0 === f[r] && (e.addEventListener(t, v, !0), f[r] = []), f[r].push(o), n;\n    }, n.off = function (t, o) {\n      var r = t.toLowerCase();\n      if (void 0 !== f[r]) return o ? f[r].splice(f[r].indexOf(o), 1) : f[r].splice(0), 0 === f[r].length && (f[r] = void 0, e.removeEventListener(t, v, !0)), n;\n      e.removeEventListener(t, o, !0);\n    }, n.once = function (t, o) {\n      return e.addEventListener(t, o, {\n        once: !0\n      }), n;\n    }, n.destroy = function () {\n      for (var t in f) n.off(t);\n\n      for (var t in n.playlist.list.splice(0), n.playlist.original.splice(0), n) delete n[t];\n\n      n = null, e.pause(), e.innerHTML = \"\";\n    };\n    var p = !1;\n\n    function m() {\n      p || (p = !0, n.on(\"ended\", function () {\n        n.playlist.currentIndex < n.playlist.list.length - 1 ? n.playlist.next(!0) : n.playlist.loop && n.playlist.play(0);\n      }));\n    }\n\n    function h(e) {\n      if (f[e]) for (var t = 0; t < f[e].length; t++) f[e][t](n, n.playlist, n.playlist.currentIndex);\n    }\n\n    n.playlist = {\n      currentIndex: 0,\n      list: [],\n      original: [],\n      loop: !1,\n      shuffled: !1,\n      reload: function (e) {\n        this.original = e, this.shuffle(this.shuffled), m();\n      },\n      add: function (e) {\n        this.original.push(e), this.shuffle(this.shuffled), m();\n      },\n      remove: function (e) {\n        this.original.splice(e, 1), this.shuffle(this.shuffled);\n      },\n      next: function (e) {\n        if (this.currentIndex++, this.currentIndex >= this.list.length) {\n          if (!this.loop) return void this.currentIndex--;\n          this.currentIndex = 0;\n        }\n\n        e ? this.play(this.currentIndex) : h(\"playlistchange\");\n      },\n      previous: function (e) {\n        if (this.currentIndex--, this.currentIndex < 0) {\n          if (!this.loop) return void this.currentIndex++;\n          this.currentIndex = this.list.length - 1;\n        }\n\n        e ? this.play(this.currentIndex) : h(\"playlistchange\");\n      },\n      play: function (e) {\n        this.currentIndex = e, h(\"playlistchange\");\n        var t = this.list[e].stream;\n        n.currentSrc === t ? n.play() : n.prepare(this.list[e].stream, function () {\n          n.play();\n        });\n      },\n      shuffle: function (e) {\n        var n, t, o;\n        if (!0 === e) for (o = this.list.length - 1; o > 0; o--) n = Math.floor(Math.random() * (o + 1)), t = this.list[o], this.list[o] = this.list[n], this.list[n] = t;else this.list = this.original.slice(0);\n        this.shuffled = e;\n      }\n    };\n  },\n      v = function (e, t) {\n    var r = this;\n    t || (t = 1e3), r.debug = !1, r.mediaStream = !1, r.onRecordingReady = null, r.onBufferProcess = null, r.onStop = null, r.mediaRecorder = null, r.recordingReady = !1, r.recording = !1, r.mediaGranted = !1, void 0 === e && (e = {}), void 0 !== e.element && (e.mediaStream = e.element.captureStream()), r.debug = e.debug, r.workerOptions = e.workerOptions, r.options = e;\n    var c = e.video ? \"video\" : \"audio\",\n        u = n.MediaRecorder,\n        d = !1;\n    if (n.OpusMediaRecorder && (e.alwaysUsePolyfill ? d = !0 : n.MediaRecorder ? d = e.mimeType && u.isTypeSupported(e.mimeType) ? n.MediaRecorder === n.OpusMediaRecorder : e.mimeType ? OpusMediaRecorder.isTypeSupported(e.mimeType) : n.MediaRecorder === n.OpusMediaRecorder : (e.mimeType || (e.mimeType = \"audio/webm;codecs=opus\"), d = OpusMediaRecorder.isTypeSupported(e.mimeType)), d && (u = OpusMediaRecorder, \"video\" === c && console.log(\"opus-media-recorder does not support video recording.\"))), !u) throw \"MediaRecorder is not available\";\n\n    if (e.mimeType && !u.isTypeSupported(e.mimeType) && (console.log(\"MediaRecorder doesn't supports mimetype \" + e.mimeType), e.mimeType = null), !e.mimeType) {\n      var s = !1,\n          f = \"audio\" === c ? a : i;\n\n      for (var v in f) {\n        for (var p = c + \"/\" + v, m = f[v], h = 0; h < m.length; h++) {\n          var y = p + \";codecs=\" + m[h];\n\n          if (u.isTypeSupported(y) && MediaSource.isTypeSupported(y)) {\n            s = y;\n            break;\n          }\n        }\n\n        if (!1 === s && u.isTypeSupported(p) && MediaSource.isTypeSupported(p) && (s = p), !1 !== s) break;\n      }\n\n      e.mimeType = s, r.debug && console.log(\"mimeType: \" + s);\n    }\n\n    var g = function (a) {\n      if (r.mediaGranted = !0, void 0 !== e.audio) if (r.source = o.audioContext.createMediaStreamSource(a), r.mediaStream = a = r.destination.stream, 0 !== b.length) {\n        for (var i = 0; i < b.length; i++) r.source.connect(b[i]);\n\n        x = !1, b.length = 0;\n      } else r.source.connect(r.destination);\n      r.bufferHeader = null;\n      var c = !1;\n      r.mediaRecorder = d ? new u(a, e, r.workerOptions) : new u(a, e), r.debug && console.log(\"MediaRecorder obtained\"), r.mediaRecorder.onstart = function (e) {\n        r.recording = !0;\n      };\n      var s = void 0 !== e.video,\n          f = s ? 565 : 100;\n      r.mediaRecorder.ondataavailable = function (o) {\n        if (!1 === c) {\n          if (\"recording\" === r.mediaRecorder.state && !(o.data.size <= 1)) {\n            r.bufferHeader = o.data;\n\n            var a = function (e) {\n              if (!n.chrome && \"audio/webm;codecs=opus\" === e) return !1;\n              var t = l[e];\n              if (void 0 === t) return !1;\n              if (t.constructor === Blob) return t;\n              t = atob(t);\n\n              for (var o = new Uint8Array(t.length), r = 0; r < t.length; r++) o[r] = t.charCodeAt(r);\n\n              return l[e] = new Blob([o]);\n            }(r.mediaRecorder.mimeType);\n\n            !1 !== a && (r.bufferHeader = a), ((c = r.bufferHeader.size) > 900 || c < 100) && console.log(\"%c[WARN] The buffer header length was more than 0.9KB or smaller than 0.1KB. This sometime cause decode error on streamer side. Try to avoid any heavy CPU usage when using the recorder.\", \"color:yellow\"), r.onRecordingReady && r.onRecordingReady({\n              mimeType: e.mimeType,\n              startTime: Date.now(),\n              hasVideo: s,\n              data: r.bufferHeader\n            }), r.recordingReady = !0, t !== f && (r.mediaRecorder.stop(), setTimeout(function () {\n              r.mediaRecorder.start(t);\n            }, 10));\n          }\n        } else {\n          var i = Number(String(Date.now()).slice(-5, -3));\n          r.onBufferProcess([o.data, i]);\n        }\n      }, r.mediaRecorder.start(f);\n    },\n        b = [];\n\n    r.source = void 0, r.destination = o.audioContext.createMediaStreamDestination();\n    var x = !0;\n\n    function T(e) {\n      for (var n = e.getTracks(), o = 0; o < n.length; o++) r.mediaRecorder.stream.addTrack(n[o]);\n\n      r.mediaRecorder.start(t), r.recording = !0;\n    }\n\n    r.connect = function (e) {\n      if (void 0 !== r.source) {\n        if (x) {\n          try {\n            r.source.disconnect(r.destination);\n          } catch (e) {}\n\n          x = !1;\n        }\n\n        r.source.connect(e);\n      } else b.push(e);\n    }, r.disconnect = function (e) {\n      if (r.source) r.source.disconnect(e);else {\n        var n = b.indexOf(e);\n        if (-1 === n) return;\n        b.splice(n, 1);\n      }\n    };\n    var M = !1;\n    r.startRecording = function () {\n      return M ? (M = !1, void (e.mediaStream || (r.options.screen ? navigator.mediaDevices.getDisplayMedia(e).then(T).catch(console.error) : navigator.mediaDevices.getUserMedia(e).then(T).catch(console.error)))) : !1 === r.mediaGranted || null === r.mediaRecorder ? (r.recordingReady = !1, e.mediaStream ? g(e.mediaStream) : r.options.screen ? navigator.mediaDevices.getDisplayMedia(e).then(g).catch(console.error) : navigator.mediaDevices.getUserMedia(e).then(g).catch(console.error), !1) : (\"recording\" !== r.mediaRecorder.state && (r.mediaRecorder.start(t), r.recording = !0), !0);\n    }, r.stopRecording = function () {\n      if (r.recording && r.mediaRecorder) {\n        if (r.recording = !1, r.mediaRecorder.stop(), !e.mediaStream) for (var n = r.mediaRecorder.stream.getTracks(), t = 0; t < n.length; t++) n[t].stop(), r.mediaRecorder.stream.removeTrack(n[t]);\n        r.bufferHeader = null, M = !0, r.onStop && r.onStop();\n      }\n    };\n  };\n\n  v.isTypeSupported = function (e) {\n    return MediaSource.isTypeSupported(e) ? !MediaRecorder || !MediaRecorder.isTypeSupported(e) || n.OpusMediaRecorder && !n.OpusMediaRecorder.isTypeSupported(e) ? \"MediaRecorder is not supporting this type\" : \"Maybe supported\" : \"MediaSource is not supporting this type\";\n  }, r.chorus = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createGain(),\n        i = n.createGain(),\n        c = n.createChannelSplitter(2),\n        u = n.createChannelMerger(2);\n    e.connect(c), e.connect(a);\n\n    for (var d = [{}, {}], l = 0; l < d.length; l++) {\n      var s = d[l];\n      s.stream = n.createGain(), s.delayVibrato = n.createDelay(), s.delayFixed = n.createDelay(), s.feedback = n.createGain(), s.feedforward = n.createGain(), s.blend = n.createGain(), c.connect(s.stream, l, 0), s.stream.connect(s.delayVibrato), s.stream.connect(s.delayFixed), s.delayVibrato.connect(s.feedforward), s.delayVibrato.connect(u, 0, l), s.delayFixed.connect(s.feedback), s.feedback.connect(s.stream), s.blend.connect(u, 0, l);\n    }\n\n    u.connect(i), a.connect(t), i.connect(t);\n    var f = n.createOscillator(),\n        v = n.createGain(),\n        p = n.createGain();\n    f.connect(v), f.connect(p), v.connect(d[0].delayVibrato.delayTime), p.connect(d[1].delayVibrato.delayTime), f.start(0), f.type = \"sine\", f.frequency.value = .15, v.gain.value = .013, p.gain.value = -.017, d[0].delayFixed.delayTime.value = .005, d[1].delayFixed.delayTime.value = .007, d[0].delayVibrato.delayTime.value = .013, d[1].delayVibrato.delayTime.value = .017;\n    var m = {\n      rate: 0,\n      intensity: 0,\n      mix: 0\n    },\n        h = {\n      output: t,\n      input: r,\n      rate: function (e) {\n        if (void 0 === e) return m.rate;\n        m.rate = e, e = .29 * e + .01, f.frequency.value = e;\n      },\n      intensity: function (e) {\n        if (void 0 === e) return m.intensity;\n        m.intensity = e;\n\n        for (var n = 1 - .2929 * e, t = .2929 * e + .7071, o = .7071 * e, r = 0; r < d.length; r++) d[r].blend.gain.value = n, d[r].feedforward.gain.value = t, d[r].feedback.gain.value = o;\n      },\n      mix: function (e) {\n        if (void 0 === e) return m.mix;\n        m.mix = e, a.gain.value = e;\n      },\n      destroy: function () {\n        r && r.disconnect(), t.disconnect(), f.stop(0), f.disconnect();\n\n        for (var e = 0; e < d.length; e++) d[e].stream.disconnect();\n\n        for (var n in this) delete this[n];\n\n        t = null;\n      }\n    };\n    return h.rate(.5), h.intensity(0), h.mix(.75), h;\n  }, r.conReverb = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createConvolver(),\n        i = n.createGain(),\n        c = n.createGain();\n\n    function u(t) {\n      null !== a.buffer && (a.disconnect(), a = n.createConvolver(), e.connect(a), a.connect(i)), a.buffer = t;\n    }\n\n    return e.connect(c), e.connect(a), a.connect(i), c.connect(t), i.connect(t), {\n      output: t,\n      input: r,\n      setBuffer: u,\n      loadBuffer: function (e) {\n        var t = new XMLHttpRequest();\n        t.open(\"GET\", e, !0), t.responseType = \"arraybuffer\", t.onload = function () {\n          var e = t.response;\n          n.decodeAudioData(e, function (e) {\n            u(e);\n          }, function (e) {\n            e.err;\n          });\n        }, t.send();\n      },\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        c.gain.value = 1 - e, i.gain.value = e;\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), c.disconnect(), t.disconnect(), a.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n  }, r.cutOff = function (e, n) {\n    var t = o.audioContext,\n        r = t.createGain(),\n        a = void 0 === n ? t.createGain() : null;\n    a && (n = a);\n    var i = t.createBiquadFilter();\n    return i.type = e || \"lowpass\", i.frequency.value = 350, i.Q.value = 1, i.connect(r), n.connect(i), {\n      output: r,\n      input: a,\n      type: function (e) {\n        if (void 0 === e) return i.type;\n        i.type = e;\n      },\n      frequency: function (e) {\n        if (void 0 === e) return i.frequency.value;\n        i.frequency.value = e;\n      },\n      width: function (e) {\n        if (void 0 === e) return i.Q.value;\n        i.Q.value = e;\n      },\n      destroy: function () {\n        for (var e in a && a.disconnect(), i.disconnect(), r.disconnect(), this) delete this[e];\n\n        r = null;\n      }\n    };\n  }, r.delay = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createGain(),\n        i = n.createGain(),\n        c = n.createGain(),\n        u = n.createDelay();\n    e.connect(a), a.connect(t), u.connect(c), c.connect(u), e.connect(u), u.connect(i), i.connect(t);\n    var d = {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        a.gain.value = 1 - e, i.gain.value = e;\n      },\n      time: function (e) {\n        if (void 0 === e) return u.delayTime.value;\n        u.delayTime.value = e;\n      },\n      feedback: function (e) {\n        if (void 0 === e) return c.gain.value;\n        c.gain.value = e;\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), a.disconnect(), i.disconnect(), c.disconnect(), u.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n    return d.mix(.5), d.time(.3), d.feedback(.5), d;\n  }, r.distortion = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = 57 * Math.PI / 180,\n        i = n.createWaveShaper();\n    i.connect(t), e.connect(i);\n    var c = {\n      amount: 0\n    };\n    return {\n      set: function (e) {\n        if (void 0 === e) return c.amount;\n        c.amount = e, e *= 10;\n\n        for (var t = new Float32Array(n.sampleRate), o = 2 / n.sampleRate, r = 0; r < n.sampleRate; r++) {\n          var u = r * o - 1;\n          t[r] = (3 + e) * u * a / (Math.PI + e * Math.abs(u));\n        }\n\n        i.curve = t;\n      },\n      output: t,\n      input: r,\n      destroy: function () {\n        for (var e in r && r.disconnect(), i.disconnect(), t.disconnect(), i = t = null, this) delete this[e];\n      }\n    };\n  }, r.dubDelay = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createGain(),\n        i = n.createGain(),\n        c = n.createGain(),\n        u = n.createDelay(),\n        d = n.createBiquadFilter();\n    e.connect(a), a.connect(t), e.connect(i), e.connect(c), c.connect(d), d.connect(u), u.connect(c), u.connect(i), i.connect(t);\n    var l = {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        a.gain.value = 1 - e, i.gain.value = e;\n      },\n      time: function (e) {\n        if (void 0 === e) return u.delayTime.value;\n        u.delayTime.value = e;\n      },\n      feedback: function (e) {\n        if (void 0 === e) return c.gain.value;\n        c.gain.value = e;\n      },\n      cutoff: function (e) {\n        if (void 0 === e) return d.frequency.value;\n        d.frequency.value = e;\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), a.disconnect(), i.disconnect(), c.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n    return l.mix(.5), l.time(.7), l.feedback(.6), l.cutoff(700), l;\n  }, r.equalizer = function (e, n) {\n    var t = e || [32, 64, 125, 250, 500, 1e3, 2e3, 4e3, 8e3, 16e3],\n        r = o.audioContext,\n        a = r.createGain(),\n        i = void 0 === n ? r.createGain() : null;\n    i && (n = i);\n\n    for (var c = {}, u = t.length - 1, d = 0; d < t.length; d++) {\n      var l = r.createBiquadFilter();\n      l.gain.value = 0, l.frequency.value = t[d], l.type = 0 === d ? \"lowshelf\" : d === u ? \"highshelf\" : \"peaking\", 0 !== d && c[t[d - 1]].connect(l), c[t[d]] = l;\n    }\n\n    return n.connect(c[t[0]]), l.connect(a), {\n      output: a,\n      input: i,\n      frequency: function (e, n) {\n        if (void 0 === n) return c[e].gain.value;\n        c[e].gain.value = n;\n      },\n      destroy: function () {\n        for (var e = 0; e < t.length; e++) c[t[e]].disconnect();\n\n        for (var n in c.splice(0), i && i.disconnect(), a.disconnect(), this) delete this[n];\n\n        c = a = null;\n      }\n    };\n  }, r.fade = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    return r && (e = r), t.gain.value = 1, e.connect(t), {\n      output: t,\n      input: r,\n      in: function (e, o, r) {\n        t.gain.cancelScheduledValues(n.currentTime);\n        var a = (1 - t.gain.value) * e;\n        t.gain.setTargetAtTime(1, n.currentTime, a * o), r && setTimeout(r, 1e3 * o);\n      },\n      out: function (e, o, r) {\n        t.gain.cancelScheduledValues(n.currentTime);\n        var a = t.gain.value * e;\n        t.gain.setTargetAtTime(1e-5, n.currentTime, a / o), r && setTimeout(r, 1e3 * o);\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n  }, r.flanger = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createGain(),\n        i = n.createGain(),\n        c = n.createGain(),\n        u = n.createDelay(),\n        d = n.createOscillator(),\n        l = n.createGain(),\n        s = n.createGain();\n    d.type = \"sine\", e.connect(a), e.connect(c), a.connect(u), a.connect(i), u.connect(i), u.connect(s), s.connect(a), d.connect(l), l.connect(u.delayTime), c.connect(t), i.connect(t), d.start(0);\n    var f = {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        c.gain.value = 1 - e, i.gain.value = e;\n      },\n      time: function (e) {\n        if (void 0 === e) return o.extra.denormalize(u.delayTime.value, .001, .02);\n        u.delayTime.value = o.extra.normalize(e, .001, .02);\n      },\n      speed: function (e) {\n        if (void 0 === e) return o.extra.denormalize(u.delayTime.value, .5, 5);\n        d.frequency.value = o.extra.normalize(e, .5, 5);\n      },\n      depth: function (e) {\n        if (void 0 === e) return o.extra.denormalize(u.delayTime.value, 5e-4, .005);\n        l.gain.value = o.extra.normalize(e, 5e-4, .005);\n      },\n      feedback: function (e) {\n        if (void 0 === e) return o.extra.denormalize(u.delayTime.value, 0, .8);\n        s.gain.value = o.extra.normalize(e, 0, .8);\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), a.disconnect(), c.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n    return f.time(.45), f.speed(.2), f.depth(.1), f.feedback(.1), f.mix(.5), f;\n  }, r.harmonizer = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n\n    for (var a = [], i = [], c = [], u = 0; u < 8; u++) a[u] = n.createBiquadFilter(), a[u].type = \"bandpass\", i[u] = n.createBiquadFilter(), i[u].type = \"bandpass\", e.connect(a[u]), c[u] = n.createGain(), c[u].connect(t), a[u].connect(i[u]).connect(c[u]);\n\n    t.gain.value = 35;\n    var d = {\n      pitch: 0,\n      slope: 0,\n      width: 0\n    },\n        l = {\n      output: t,\n      input: r,\n      pitch: function (e) {\n        if (void 0 === e) return d.pitch;\n        d.pitch = e;\n\n        for (var n = o.convert.midiToFreq(e), t = 0; t < 8; t++) a[t].frequency.value = n, i[t].frequency.value = n;\n      },\n      slope: function (e) {\n        if (void 0 === e) return d.slope;\n        d.slope = e;\n\n        for (var n = 0; n < 8; n++) c[n].gain.value = 1 + Math.sin(Math.PI + Math.PI / 2 * (e + n / 8));\n      },\n      width: function (e) {\n        if (void 0 === e) return d.width;\n        d.width = e;\n\n        for (var n = 1; n < 8; n++) {\n          var t = 2 + 90 * Math.pow(1 - n / 8, e);\n          a[n].Q.value = t, i[n].Q.value = t;\n        }\n      },\n      destroy: function () {\n        r && r.disconnect(), t.disconnect();\n\n        for (var e = 0; e < 8; e++) a[e].disconnect();\n\n        for (var n in this) delete this[n];\n\n        t = null;\n      }\n    };\n    return l.pitch(34), l.slope(.65), l.width(.15), l;\n  }, r.noise = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n\n    for (var a = Math.floor(9.73 * n.sampleRate), i = new Float32Array(a), c = 0; c < a; c++) i[c] = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random()) * .5;\n\n    var u = n.createBuffer(2, a, n.sampleRate);\n    u.getChannelData(0).set(i, 0), u.getChannelData(1).set(i, 0);\n    var d = n.createBufferSource();\n    return d.to(t), d.loop = !0, d.start(0), d.buffer = u, d.loopStart = 9.73 * Math.random(), {\n      output: t,\n      input: r,\n      destroy: function () {\n        for (var e in d.loop = !1, d.buffer = null, d.stop(0), d.disconnect(), d = null, r && r.disconnect(), t.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n  }, r.pingPongDelay = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createDelay(),\n        i = n.createDelay(),\n        c = n.createGain(),\n        u = n.createGain(),\n        d = n.createGain(),\n        l = n.createChannelMerger(2);\n    e.connect(c), c.connect(t), a.connect(l, 0, 0), i.connect(l, 0, 1), a.connect(i), d.connect(a), i.connect(d), e.connect(d), l.connect(u), u.connect(t);\n    var s = {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return u.gain.value;\n        c.gain.value = 1 - e, u.gain.value = e;\n      },\n      time: function (e) {\n        if (void 0 === e) return a.delayTime.value;\n        a.delayTime.value = e, i.delayTime.value = e;\n      },\n      feedback: function (e) {\n        if (void 0 === e) return d.gain.value;\n        d.gain.value = e;\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), c.disconnect(), d.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n    return s.mix(.5), s.time(.3), s.feedback(.5), s;\n  }, r.pitchShift = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = .1,\n        i = a / 2,\n        c = a * n.sampleRate,\n        u = n.createGain(),\n        d = n.createGain(),\n        l = n.createDelay(),\n        s = n.createDelay();\n    u.connect(l.delayTime), d.connect(s.delayTime), e.connect(l), e.connect(s);\n    var f = n.currentTime + i,\n        v = n.currentTime + a;\n\n    function p(e) {\n      for (var t = n.createBuffer(1, c, n.sampleRate), o = t.getChannelData(0), r = 0; r < c; r++) o[r] = e ? (c - r) / c : r / c;\n\n      return t;\n    }\n\n    for (var m = [0, 0, 0, 0], h = [0, 0, 0, 0], y = 0; y < m.length; y++) m[y] = n.createBufferSource(), m[y].loop = !0, h[y] = n.createGain(), y < 2 ? m[y].buffer = p(!1) : (m[y].buffer = p(!0), h[y].gain.value = 0), y % 2 ? (h[y].connect(d), m[y].start(v)) : (h[y].connect(u), m[y].start(f)), m[y].connect(h[y]);\n\n    var g = function () {\n      for (var e = n.createBuffer(1, c, n.sampleRate), t = e.getChannelData(0), o = i * n.sampleRate, r = c - o, a = 0; a < c; a++) t[a] = a < o ? Math.sqrt(a / o) : Math.sqrt(1 - (a - r) / o);\n\n      return e;\n    }(),\n        b = [0, 0],\n        x = [0, 0];\n\n    for (y = 0; y < b.length; y++) b[y] = n.createBufferSource(), b[y].loop = !0, b[y].buffer = g, x[y] = n.createGain(), x[y].gain.value = 0, b[y].connect(x[y].gain), y % 2 ? (h[y].connect(d), b[y].start(v)) : (h[y].connect(u), b[y].start(f)), x[y].connect(t);\n\n    function T(e) {\n      u.gain.value = d.gain.value = .5 * a * Math.abs(e);\n    }\n\n    l.connect(x[0]), s.connect(x[1]);\n    var M = {\n      output: t,\n      input: r,\n      shift: function (e) {\n        if (void 0 !== e) {\n          var n = e > 0;\n          h[0].gain.value = h[1].gain.value = n ? 0 : 1, h[2].gain.value = h[3].gain.value = n ? 1 : 0, T(e);\n        }\n      },\n      destroy: function () {\n        r && r.disconnect(), t.disconnect();\n\n        for (var e = 0; e < b.length; e++) b[e].stop(), b[e].disconnect(), x[e].disconnect();\n\n        for (e = 0; e < m.length; e++) m[e].stop(), m[e].disconnect(), h[e].disconnect();\n\n        for (var n in u.disconnect(), d.disconnect(), l.disconnect(), s.disconnect(), this) delete this[n];\n\n        t = null;\n      }\n    };\n    return T(0), M;\n  }, r.reverb = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createConvolver(),\n        i = n.createGain(),\n        c = n.createGain();\n    e.connect(c), c.connect(t), i.connect(t);\n    var u = 1,\n        d = .1,\n        l = !1;\n\n    function s() {\n      for (var t = n.sampleRate * u, o = n.createBuffer(2, t, n.sampleRate), r = o.getChannelData(0), c = o.getChannelData(1), s = 0; s < t; s++) {\n        var f = l ? t - s : s;\n        r[s] = (2 * Math.random() - 1) * Math.pow(1 - f / t, d), c[s] = (2 * Math.random() - 1) * Math.pow(1 - f / t, d);\n      }\n\n      a.disconnect(), a = n.createConvolver(), e.connect(a), a.connect(i), a.buffer = o;\n    }\n\n    return s(), {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        c.gain.value = 1 - e, i.gain.value = e;\n      },\n      time: function (e) {\n        if (void 0 === e) return u;\n        u = e, s();\n      },\n      decay: function (e) {\n        if (void 0 === e) return d;\n        d = e, s();\n      },\n      reverse: function (e) {\n        if (void 0 === e) return l;\n        l = e, s();\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), c.disconnect(), t.disconnect(), a.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n  }, r.stereoPanner = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = !1;\n\n    if (n.createStereoPanner) {\n      var i = n.createStereoPanner();\n      a = !0;\n    } else {\n      (i = n.createPanner()).type = \"equalpower\";\n    }\n\n    return e.connect(i), i.connect(t), i.pan.value = 0, {\n      output: t,\n      input: r,\n      set: function (e) {\n        if (void 0 === e) return i.pan.value;\n        a ? i.pan.value = e : i.setPosition(e, 0, 1 - Math.abs(e));\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), i.disconnect(), this) delete this[e];\n\n        t = i = null;\n      }\n    };\n  }, r.tremolo = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r);\n    var a = n.createGain(),\n        i = n.createGain(),\n        c = n.createGain();\n    c.gain.value = 0;\n    var u = n.createWaveShaper();\n    u.curve = new Float32Array([0, 1]), u.connect(c.gain), e.connect(a), a.connect(t);\n    var d = n.createOscillator();\n    d.connect(u), d.type = \"sine\", d.start(0), e.connect(c), c.connect(i), i.connect(t);\n    var l = {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        a.gain.value = 1 - e, i.gain.value = e;\n      },\n      speed: function (e) {\n        if (void 0 === e) return o.extra.denormalize(d.frequency.value, 0, 20);\n        d.frequency.value = o.extra.normalize(e, 0, 20);\n      },\n      depth: function (e) {\n        if (void 0 === e) return 1 - this.shaperNode.curve[0];\n        u.curve = new Float32Array([1 - e, 1]);\n      },\n      destroy: function () {\n        for (var e in r && r.disconnect(), t.disconnect(), a.disconnect(), c.disconnect(), this) delete this[e];\n\n        t = null;\n      }\n    };\n    return l.speed(.2), l.depth(1), l.mix(.8), l;\n  }, r.vibrato = function (e) {\n    var n = o.audioContext,\n        t = n.createGain(),\n        r = void 0 === e ? n.createGain() : null;\n    r && (e = r), console.log(\"Vibrato was not finished yet\");\n    var a = n.createDelay(),\n        i = n.createGain(),\n        c = n.createGain(),\n        u = n.createOscillator();\n    return e.connect(c), c.connect(t), i.connect(t), a.delayTime.value = 1, u.frequency.value = 3, u.type = \"sine\", u.start(0), u.connect(a.delayTime), e.connect(a), a.connect(i), {\n      output: t,\n      input: r,\n      mix: function (e) {\n        if (void 0 === e) return i.gain.value;\n        c.gain.value = 1 - e, i.gain.value = e;\n      },\n      delay: function (e) {\n        if (void 0 === e) return a.delayTime.value;\n        a.delayTime.value = e;\n      },\n      depth: function (e) {\n        if (void 0 === e) return depthNode.gain.value;\n        depthNode.gain.value = e;\n      },\n      speed: function (e) {\n        if (void 0 === e) return u.frequency.value;\n        u.frequency.value = e;\n      },\n      destroy: function () {\n        for (var n in r && r.disconnect(), t.disconnect(), e.disconnect(a), e.disconnect(c), u.stop(), u.disconnect(), depthNode.disconnect(), this) delete this[n];\n\n        t = null;\n      }\n    };\n  };\n\n  var p = function (e, n) {\n    n || (n = 1e3);\n    var t = n / 1e3,\n        r = this;\n    r.debug = !1, r.playing = !1, r.latency = 0, r.mimeType = null, r.audioContext = o.audioContext, r.outputNode = !1;\n    var a = !0,\n        i = !1,\n        c = r.audioContext.createMediaElementSource(e);\n    e.addEventListener(\"error\", function (e) {\n      console.error(e.target.error);\n    }), r.audioConnect = function (e) {\n      !0 === a && (a = !1, c.disconnect()), r.outputNode = r.audioContext.createGain(), r.outputNode.connect(e), c.connect(e);\n    }, r.audioDisconnect = function () {\n      outputNode.disconnect(), a = !0, c.disconnect(), c.connect(r.audioContext.destination);\n    }, r.stop = function () {\n      i.stop(), r.playing = !1, r.buffering = !1;\n    }, r.setBufferHeader = function (t) {\n      if (t && t.data) {\n        var o = t.data;\n        r.mimeType = t.mimeType, !1 !== i ? i.stop() : c.connect(r.audioContext.destination), i = new s(r.mimeType, n, o), e.src = r.objectURL = i.objectURL;\n      }\n    }, r.playStream = function () {\n      r.playing = !0;\n    }, r.receiveBuffer = function (n) {\n      if (!1 !== r.playing && i.append) {\n        var o = n[0],\n            a = n[1];\n        i.append(o), e.paused && e.play(), r.latency = Number(String(Date.now()).slice(-5, -3)) - a + r.audioContext.baseLatency + t, r.debug && console.log(\"Total latency: \" + r.latency);\n      }\n    };\n  };\n\n  o.extra = new function () {\n    this.isMobile = function () {\n      return /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(navigator.userAgent);\n    }, this.objectPropertyLinker = function (e, n, t) {\n      Object.defineProperty(e, t, {\n        get: function () {\n          return n[t];\n        },\n        set: function (e) {\n          n[t] = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      });\n    }, this.normalize = function (e, n, t) {\n      return (t - n) * e + n;\n    }, this.denormalize = function (e, n, t) {\n      return (e - n) / (t - n);\n    };\n    var e = 0;\n\n    this.fadeNumber = function (n, t, o, r, a, i) {\n      e = 0;\n      var c = n,\n          u = r / (Math.abs(n - t) / Math.abs(o));\n      if (u && u != 1 / 0) var d = setInterval(function () {\n        if (e >= 100 && clearInterval(d), e++, c = 1e3 * (c + o), c = Math.ceil(c) / 1e3, o >= 0 && (c >= t || n >= t) || o <= 0 && (c <= t || n <= t) || c == 1 / 0 || !c) return clearInterval(d), a(t), void (i && i());\n        a && a(c);\n      }, u);else setTimeout(function () {\n        a && a(t), i && i();\n      }, r);\n    };\n\n    var n = [],\n        t = 0;\n    this.preciseTimeout = function (e, o) {\n      var r = Date.now();\n      return t++, n.push({\n        id: t,\n        when: r + o,\n        func: e,\n        fallback: setTimeout(function () {\n          a(t).func();\n        }, o)\n      }), c(), t;\n    }, this.clearPreciseTimeout = function (e) {\n      a(e, n);\n    };\n    var o = [],\n        r = 0;\n\n    function a(e, n) {\n      for (var t in n) if (n[t].id === e) return n.splice(t, 1);\n    }\n\n    this.preciseInterval = function (e, n) {\n      var t = Date.now(),\n          a = {\n        id: ++r,\n        interval: n,\n        when: t + n,\n        func: e\n      };\n      return a.fallback = setInterval(function () {\n        a.when >= Date.now() || (a.when += a.interval, a.func());\n      }, n), o.push(a), c(), r;\n    }, this.clearPreciseInterval = function (e) {\n      var n = a(e, o);\n      clearInterval(n.fallback);\n    };\n    var i = !1;\n\n    function c() {\n      if (!i) {\n        i = !0;\n        requestAnimationFrame(function e() {\n          if (0 !== n.length || 0 !== o.length) {\n            requestAnimationFrame(e);\n            var t = Date.now();\n\n            for (var r in n) n[r].when < t && (n[r].func(), clearTimeout(n[r].fallback), n.splice(r, 1));\n\n            for (var r in o) o[r].when < t && (o[r].func(), o[r].when += o[r].interval);\n          } else i = !1;\n        });\n      }\n    }\n  }(), t ? (e.Media = o, e.MediaEffect = r, e.AudioStreamer = d, e.VideoStreamer = p, e.MediaPlayer = f, e.MediaPresenter = v, e.MediaBuffer = s) : (e.ScarletsMedia = o, e.ScarletsMediaEffect = r, e.ScarletsAudioStreamer = d, e.ScarletsVideoStreamer = p, e.ScarletsMediaPlayer = f, e.ScarletsMediaPresenter = v, e.ScarletsMediaBuffer = s);\n});","map":{"version":3,"mappings":"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","names":["module","factory","this","audioContext","getElementAudioNode","elem","getElementVideoNode","ScarletsMediaEffect","audioCodecs","webm","mp4","ogg","videoCodecs","3gpp","waitingUnlock","userInteracted","ScarletsMedia","source","removeListener","resume","document","chunksDuration","scope","bufferHeader","mediaBuffer","audioElement","audioNode","console","error","node","directAudioOutput","destination","onStop","mimeType","noiseLength","length","temp","index","onended","disconnect","buffer","newBuffer","i","cleanNoise","streamingTime","bufferElementIndex","finalBuffer","addBufferHeader","arrayBuffer","webAudioBufferInsert","latency","BufferHeader","audio/webm;codecs=opus","midiToFreq","midi","freqToMidi","Math","freq","powerToDb","db","dbToPower","ampToDb","dbToAmp","velToAmp","totalTime","sourceBuffer","buffers","mode","e","removing","startAppending","shift","endOfStream","ScarletsMediaPlayer","element","audioOutputNode","Object","get","enumerable","propertyLinker","videoOutputNode","self","load","canPlayType","set","stillWaiting","successCallback","catch","play","errorCallback","num","callback","eventRegistered","undefined","once","playlistInitialized","currentIndex","list","original","loop","shuffled","reload","lists","internalPlaylistEvent","add","obj","remove","next","autoplay","playlistTriggerEvent","previous","shuffle","j","x","ScarletsMediaPresenter","options","MediaRecorder","usingOpusMediaRecorderPolyfill","window","OpusMediaRecorder","codecsList","codecs","supportedMimeType","MediaSource","firstSourceConnect","pendingConnect","headerLatency","state","buff","UInt","getBufferHeader","predefinedBuffer","bufferHeaderLength","startTime","hasVideo","data","setTimeout","afterStop","navigator","mediaGranted","stop","streams","output","input","wet","splitter","merger","sourceNode","c","dry","LDepth","RDepth","lfo","channel","rate","intensity","mix","ret","value","feedforward","feedback","destroy","wetGainNode","dryGainNode","reverbNode","setBuffer","loadBuffer","ajaxRequest","context","err","send","filterNode","type","frequency","width","feedbackGainNode","delayNode","time","waveShaperNode","amount","curve","key","bqFilterNode","cutoff","lastIndex","filter","equalizer","dB","in","out","oscillatorNode","gainNode","feedbackNode","inputFeedbackNode","speed","depth","filters1","filters2","gains","pitch","slope","f0","q","noiseFloat32","noiseBuffer","src","delayNodeLeft","delayNodeRight","channelMerger","fadeTime","bufferRate","modulateGain1","modulateGain2","delayNode1","delayNode2","bTime","shiftUp","bufferGain","bufferSource","fadeLength","bufferLeft","createPitchFadeBuffer","fadeNode","mixNode","pitchGain","decay","reverse","impulse","impulseL","impulseR","rebuildImpulse","stereoSupport","pannerNode","pan","tremoloGainNode","shaperNode","lfoNode","delay","depthNode","videoElement","outputNode","objectURL","isMobile","userAgent","objectPropertyLinker","property","target","configurable","normalize","min","denormalize","fadeNumber","maxFade","interval","current","increment","Infinity","clearInterval","onIncrease","to","onFinish","setInterval","timeoutIncrement","preciseTimeout","timeout","id","when","func","fallback","clearPreciseTimer","miliseconds","startPreciseTime","clearPreciseTimeout","intervalIncrement","preciseInterval","clearPreciseInterval","preciseTimerStarted","requestAnimationFrame","clearTimeout","moduleMode","global","MediaBuffer"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\a_init.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\AudioStreamer.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\BufferHeader.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Convert.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\MediaBuffer.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\MediaPlayer.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\MediaPresenter.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Chorus.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\ConReverb.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\CutOff.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Delay.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Distortion.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\DubDelay.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Equalizer.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Fade.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Flanger.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Harmonizer.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Noise.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\PingPongDelay.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\PitchShift.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Reverb.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\StereoPanner.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Tremolo.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\Plugin\\Vibrato.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\VideoStreamer.js","D:\\Projects\\React\\PTT-react\\client\\node_modules\\sfmediastream\\dist\\z_extra.js"],"sourcesContent":["/*\r\n\tScarletsFiction MediaStream Library\r\n\r\n\tHTML5 media streamer library for playing music, video, playlist,\r\n\tor even live streaming microphone & camera with node server\r\n\thttps://github.com/ScarletsFiction/SFMediaStream\r\n*/\r\n(function(global, factory){\r\n  if(typeof exports === 'object' && typeof module !== 'undefined'){\r\n  \tmodule.exports = {};\r\n  \tfactory(module.exports, window, true);\r\n  }\r\n  else factory(global, window);\r\n}(this || window, (function(global, window, moduleMode){'use strict';\r\n// ===== Module Init =====\r\n\r\n// Initialize global data\r\nvar ScarletsMedia = {\r\n\taudioContext: false, // Created after user gesture\r\n\r\n\t// Get Audio Node from HTML5's audio tag\r\n\tgetElementAudioNode:function(elem){\r\n\t\telem.crossOrigin = 'anonymous';\r\n\t\treturn this.audioContext.createMediaElementSource(elem);\r\n\t},\r\n\r\n\t// videoContext: window.VideoContext ? new VideoContext() : false,\r\n\r\n\t// Still underdevelopment: https://github.com/bbc/VideoContext\r\n\tgetElementVideoNode:function(elem){\r\n\t\telem.crossOrigin = 'anonymous';\r\n\t\treturn null;\r\n\t}\r\n};\r\n\r\nvar ScarletsMediaEffect = {};\r\nvar audioCodecs = {\r\n\twebm:['opus', 'vorbis'],\r\n\tmp4:['mp4a.67', 'mp4a.40.29', 'mp4a.40.5', 'mp4a.40.2', 'mp3'],\r\n\togg:['opus', 'vorbis'], // This may not work on mobile\r\n};\r\nvar videoCodecs = {\r\n\twebm:['vp8,opus', 'vp8,vorbis'],\r\n\tmp4:['mp4v.20.8,mp4a.40.2', 'mp4v.20.240,mp4a.40.2', 'avc1.42E01E,mp4a.40.2', 'avc1.58A01E,mp4a.40.2', 'avc1.64001E,mp4a.40.2'],\r\n\t'3gpp':['mp4v.20.8,samr'],\r\n\togg:['dirac,vorbis', 'theora,vorbis'], // This may not work on mobile\r\n};\r\n\r\nvar waitingUnlock = [];\r\nvar userInteracted = false;\r\n\r\n// Unlock mobile media security\r\n(function(){\r\n\tconst AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\tif(!AudioContext) return console.error(\"`AudioContext` was not available\");\r\n\tScarletsMedia.audioContext = new AudioContext();\r\n\r\n\tvar mobileMediaUnlock = function(e){\r\n\t\tvar emptyBuffer = ScarletsMedia.audioContext.createBuffer(1, 1, 22050);\r\n\t\tvar source = ScarletsMedia.audioContext.createBufferSource();\r\n\t\tsource.buffer = emptyBuffer;\r\n\t\tsource.connect(ScarletsMedia.audioContext.destination);\r\n\r\n\t\tsource.onended = function(){\r\n\t\t\tsource.disconnect(0);\r\n\t\t\tsource = emptyBuffer = null;\r\n\r\n\t\t\tremoveListener();\r\n\t\t}\r\n\r\n\t\t// Play the empty buffer.\r\n\t\tif(!source.start) source.noteOn(0);\r\n\t\telse source.start(0);\r\n\t\tScarletsMedia.audioContext.resume();\r\n\t}\r\n\r\n\tfunction removeListener(){\r\n\t\tdocument.removeEventListener('touchstart', mobileMediaUnlock, true);\r\n\t\tdocument.removeEventListener('touchend', mobileMediaUnlock, true);\r\n\t\tdocument.removeEventListener('click', mobileMediaUnlock, true);\r\n\r\n\t\tfor (var i = 0; i < waitingUnlock.length; i++) {\r\n\t\t\twaitingUnlock[i]();\r\n\t\t}\r\n\r\n\t\twaitingUnlock.length = 0;\r\n\t}\r\n\r\n\tdocument.addEventListener('touchstart', mobileMediaUnlock, true);\r\n\tdocument.addEventListener('touchend', mobileMediaUnlock, true);\r\n\tdocument.addEventListener('click', mobileMediaUnlock, true);\r\n})();","// Minimum 3 bufferElement\r\nvar ScarletsAudioStreamer = function(chunksDuration){\r\n\tif(!chunksDuration) chunksDuration = 1000;\r\n\tvar chunksSeconds = chunksDuration/1000;\r\n\r\n\tvar scope = this;\r\n\r\n\tscope.debug = false;\r\n\tscope.playing = false;\r\n\tscope.latency = 0;\r\n\tscope.mimeType = null;\r\n\tscope.bufferElement = [];\r\n\r\n\tscope.onStop = null;\r\n\r\n\tscope.audioContext = ScarletsMedia.audioContext;\r\n\tscope.outputNode = false; // Set this to a connectable Audio Node\r\n\r\n\t// If the outputNode is not set, then the audio will be outputted directly\r\n\tvar directAudioOutput = true;\r\n\r\n\tvar bufferHeader = false;\r\n\tvar mediaBuffer = false;\r\n\r\n\tvar audioElement = scope.element = new Audio();\r\n\tvar audioNode = scope.audioContext.createMediaElementSource(audioElement);\r\n\r\n\t// ToDo: we may need to try to recreate the element if error happen\r\n\t// Or reducing the extra latency\r\n\taudioElement.addEventListener('error', function(e){\r\n\t\tconsole.error(e.target.error);\r\n\t});\r\n\r\n\tscope.connect = function(node){\r\n\t\tif(directAudioOutput === true){\r\n\t\t\tdirectAudioOutput = false;\r\n\t\t\taudioNode.disconnect();\r\n\t\t}\r\n\r\n\t\tscope.outputNode = scope.audioContext.createGain();\r\n\t\tscope.outputNode.connect(node);\r\n\t\taudioNode.connect(node);\r\n\t}\r\n\r\n\tscope.disconnect = function(node){\r\n\t\tscope.outputNode.disconnect(node);\r\n\t\tdirectAudioOutput = true;\r\n\r\n\t\taudioNode.disconnect(node);\r\n\t\taudioNode.connect(scope.audioContext.destination);\r\n\t}\r\n\r\n\tscope.stop = function(){\r\n\t\tmediaBuffer.stop();\r\n\t\tscope.playing = false;\r\n\t\tscope.buffering = false;\r\n\t\tif (scope.onStop) scope.onStop();\r\n\t}\r\n\r\n\tscope.setBufferHeader = function(packet){\r\n\t\tif(!packet.data){\r\n\t\t\tbufferHeader = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar arrayBuffer = packet.data;\r\n\t\tscope.mimeType = packet.mimeType;\r\n\r\n\t\tif(mediaBuffer !== false)\r\n\t\t\tmediaBuffer.stop();\r\n\t\telse audioNode.connect(scope.audioContext.destination);\r\n\r\n\t\tmediaBuffer = new MediaBuffer(scope.mimeType, chunksDuration, arrayBuffer);\r\n\t\tbufferHeader = new Uint8Array(arrayBuffer);\r\n\r\n\t\taudioElement.src = scope.objectURL = mediaBuffer.objectURL;\r\n\r\n\t\t// Get buffer noise length\r\n\t\tscope.audioContext.decodeAudioData(arrayBuffer.slice(0), function(audioBuffer){\r\n\t\t\t// headerDuration = audioBuffer.duration;\r\n\t\t\tnoiseLength = audioBuffer.getChannelData(0).length;\r\n\t\t});\r\n\t}\r\n\r\n\t// ===== For handling WebAudio =====\r\n\tfunction createBufferSource(){\r\n\t\tvar temp = scope.audioContext.createBufferSource();\r\n\t\ttemp.onended = function(){\r\n\t\t\tthis.stop();\r\n\t\t\tthis.disconnect();\r\n\t\t}\r\n\t\treturn temp;\r\n\t}\r\n\r\n\tvar addBufferHeader = function(arrayBuffer){\r\n\t\tvar finalBuffer = new Uint8Array(bufferHeader.byteLength + arrayBuffer.byteLength);\r\n\t\tfinalBuffer.set(bufferHeader, 0);\r\n\t\tfinalBuffer.set(new Uint8Array(arrayBuffer), bufferHeader.byteLength);\r\n\t\treturn finalBuffer.buffer;\r\n\t}\r\n\r\n\tvar noiseLength = 0;\r\n\tfunction cleanNoise(buffer){\r\n\t\tvar frameCount = buffer.getChannelData(0).length - noiseLength;\r\n\t\tif(frameCount === 0) return false;\r\n\r\n  \t\tvar channelLength = buffer.numberOfChannels;\r\n\t\tvar newBuffer = scope.audioContext.createBuffer(channelLength, frameCount, buffer.sampleRate);\r\n\r\n\t\tfor (var i = 0; i < channelLength; i++) {\r\n\t    \tnewBuffer.getChannelData(i).set(buffer.getChannelData(i).subarray(noiseLength));\r\n\t    }\r\n\r\n\t    return newBuffer;\r\n\t}\r\n\r\n\tfunction webAudioBufferInsert(index, buffer){\r\n\t\tscope.bufferElement[index] = createBufferSource();\r\n\t\tbuffer = cleanNoise(buffer);\r\n\r\n\t\tif(buffer === false) return false;\r\n\t\tscope.bufferElement[index].buffer = buffer;\r\n\r\n\t\tif(scope.outputNode && scope.outputNode.context && directAudioOutput === false)\r\n\t\t\tscope.bufferElement[index].connect(scope.outputNode);\r\n\r\n\t\telse // Direct output to destination\r\n\t\t\tscope.bufferElement[index].connect(scope.audioContext.destination);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ===== Realtime Playing =====\r\n\t// Play audio immediately after received\r\n\r\n\tscope.playStream = function(){\r\n\t\tscope.playing = true;\r\n\t}\r\n\r\n\tvar bufferElementIndex = 0;\r\n\tscope.realtimeBufferPlay = function(packet){\r\n\t\tif(scope.playing === false) return;\r\n\r\n\t\tvar arrayBuffer = packet[0];\r\n\t\tvar streamingTime = packet[1];\r\n\r\n\t\tif(scope.debug) console.log(\"Receiving data\", arrayBuffer.byteLength);\r\n\t\tif(arrayBuffer.byteLength === 0) return;\r\n\r\n\t\tscope.latency = (Number(String(Date.now()).slice(-5, -3)) - streamingTime) + chunksSeconds + scope.audioContext.baseLatency;\r\n\r\n\t\tvar index = bufferElementIndex;\r\n\t\tbufferElementIndex++;\r\n\t\tif(bufferElementIndex > 2)\r\n\t\t\tbufferElementIndex = 0;\r\n\r\n\t\tscope.audioContext.decodeAudioData(addBufferHeader(arrayBuffer), function(buffer){\r\n\t\t\tif(webAudioBufferInsert(index, buffer) === false)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tscope.bufferElement[index].start(0);\r\n\t\t});\r\n\t}\r\n\r\n\t// ====== Synchronous Playing ======\r\n\t// Play next audio when last audio was finished\r\n\r\n\tscope.receiveBuffer = function(packet){\r\n\t\tif(scope.playing === false || !mediaBuffer.append) return;\r\n\r\n\t\tvar arrayBuffer = packet[0];\r\n\t\tvar streamingTime = packet[1];\r\n\r\n\t\tmediaBuffer.append(arrayBuffer);\r\n\r\n\t\tif(audioElement.paused)\r\n\t\t\taudioElement.play();\r\n\r\n\t\tscope.latency = (Number(String(Date.now()).slice(-5, -3)) - streamingTime) +  scope.audioContext.baseLatency + chunksSeconds;\r\n\t\tif(scope.debug) console.log(\"Total latency: \"+scope.latency);\r\n\t}\r\n}\r\n","var BufferHeader = {\r\n\t\"audio/webm;codecs=opus\": \"GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwH/////////FUmpZpkq17GDD0JATYCGQ2hyb21lV0GGQ2hyb21lFlSua7+uvdeBAXPFh7o5nyc1kHqDgQKGhkFfT1BVU2Oik09wdXNIZWFkAQIAAIC7AAAAAADhjbWERzuAAJ+BAmJkgSAfQ7Z1Af/////////ngQCjjIEAAID/A//+//7//qM=\"\r\n};\r\n\r\nfunction getBufferHeader(type) {\r\n\tif (!window.chrome && type === \"audio/webm;codecs=opus\" ) {\r\n\t\t// this header is only for chrome based brosers\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar buff = BufferHeader[type];\r\n\tif(buff === void 0) return false;\r\n\r\n\tif(buff.constructor === Blob)\r\n\t\treturn buff;\r\n\r\n\tbuff = atob(buff);\r\n\r\n\tvar UInt = new Uint8Array(buff.length);\r\n\tfor (var i = 0; i < buff.length; i++)\r\n\t\tUInt[i] = buff.charCodeAt(i);\r\n\r\n\treturn BufferHeader[type] = new Blob([UInt]);\r\n}","ScarletsMedia.convert = {\r\n\t// Converts a MIDI pitch number to frequency.\r\n\t// midi = 0 ~ 127\r\n\tmidiToFreq:function (midi) {\r\n\t    if(midi <= -1500) return 0;\r\n\t    else if(midi > 1499) return 3.282417553401589e+38;\r\n\t    else return 440.0 * Math.pow(2, (Math.floor(midi) - 69) / 12.0);\r\n\t},\r\n\r\n\t// Converts frequency to MIDI pitch.\r\n\tfreqToMidi:function(freq){\r\n\t\tif(freq > 0)\r\n\t\t\treturn Math.floor(Math.log(freq/440.0) / Math.LN2 * 12 + 69);\r\n\t\telse return -1500;\r\n\t},\r\n\r\n    // Converts power to decibel. Note that it is off by 100dB to make it\r\n\tpowerToDb:function(power){\r\n\t    if (power <= 0)\r\n\t    \treturn 0;\r\n\t    else {\r\n\t        var db = 100 + 10.0 / Math.LN10 * Math.log(power);\r\n\t        if(db < 0) return 0;\r\n\t        return db;\r\n\t    }\r\n\t},\r\n\r\n    // Converts decibel to power\r\n\tdbToPower:function(db){\r\n\t    if (db <= 0) return 0;\r\n\t    else {\r\n  \t        if (db > 870) db = 870;\r\n  \t        return Math.exp(Math.LN10 * 0.1 * (db - 100.0));\r\n\t    }\r\n\t},\r\n\r\n\t// Converts amplitude to decibel.\r\n\tampToDb:function(lin){\r\n\t    return 20.0 * (lin > 0.00001 ? (Math.log(lin) / Math.LN10) : -5.0);\r\n\t},\r\n\r\n\t// Converts decibel to amplitude\r\n\tdbToAmp:function(db) {\r\n\t    return Math.pow(10.0, db / 20.0);\r\n\t},\r\n\r\n\t// Converts MIDI velocity to amplitude\r\n\tvelToAmp:function (velocity) {\r\n\t    return velocity / 127;\r\n\t},\r\n}","var MediaBuffer = function(mimeType, chunksDuration, bufferHeader){\r\n\tvar scope = this;\r\n\tscope.source = new MediaSource();\r\n\tscope.objectURL = URL.createObjectURL(scope.source);\r\n\r\n\tvar removing = false;\r\n\tvar totalTime = 0; // miliseconds\r\n\tvar sourceBuffer = null;\r\n\tvar buffers = [];\r\n\r\n\tscope.source.onsourceopen = function(){\r\n\t\tsourceBuffer = scope.source.addSourceBuffer(mimeType);\r\n\t\tsourceBuffer.mode = 'sequence';\r\n\t\tsourceBuffer.appendBuffer(bufferHeader);\r\n\r\n\t\tsourceBuffer.onerror = function(e){\r\n\t\t\tconsole.error(\"SourceBuffer error:\", e);\r\n\t\t}\r\n\r\n\t\tsourceBuffer.onupdateend = function(){\r\n\t\t\tif(removing){\r\n\t\t\t\tremoving = false;\r\n\t\t\t\ttotalTime = 10000;\r\n\r\n\t\t\t\t// 0 ~ 10 seconds\r\n\t\t\t\tsourceBuffer.remove(0, 10);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(!sourceBuffer.updating && buffers.length !== 0)\r\n\t\t\t\tstartAppending(buffers.shift());\r\n\t\t};\r\n\t};\r\n\r\n\tfunction startAppending(buffer){\r\n\t\tsourceBuffer.appendBuffer(buffer);\r\n\t\ttotalTime += chunksDuration;\r\n\t\t// console.log(totalTime, buffer);\r\n\t}\r\n\r\n\tscope.source.onerror = function(e){\r\n\t\tconsole.error(\"MediaSource error:\", e);\r\n\t}\r\n\r\n\tscope.append = function(arrayBuffer){\r\n\t\tif(sourceBuffer === null)\r\n\t\t\treturn false;\r\n\r\n\t\tif (!sourceBuffer.updating && sourceBuffer.buffered.length === 2)\r\n\t\t\t// The problem of accessing to 'sourceBuffer.buffered' is that after you append data, the SourceBuffer instance becomes temporarily unusable while it's working.\r\n\t\t\t// During this time, the SourceBuffer's updating property will be set to true, so it's easy to check for.\r\n\t\t\tconsole.log('something wrong');\r\n\r\n\t\tif(totalTime >= 20000)\r\n\t\t\tremoving = true;\r\n\r\n\t\tif(!sourceBuffer.updating)\r\n\t\t\tstartAppending(arrayBuffer);\r\n\t\telse\r\n\t\t\tbuffers.push(arrayBuffer);\r\n\r\n\t\treturn totalTime/1000;\r\n\t}\r\n\r\n\tscope.stop = function(){\r\n\t\tif(sourceBuffer.updating)\r\n\t\t\tsourceBuffer.abort();\r\n\r\n\t\tif(scope.source.readyState === \"open\")\r\n\t\t\tscope.source.endOfStream();\r\n\t}\r\n}","// https://www.w3schools.com/tags/ref_av_dom.asp\r\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement\r\nvar ScarletsMediaPlayer = function(element){\r\n\t// https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events\r\n\tvar self = this;\r\n\r\n\tif(element === void 0)\r\n\t\telement = 'audio';\r\n\r\n\tif(element.constructor === String){\r\n\t\tif(element !== 'audio' && element !== 'video')\r\n\t\t\treturn console.error('Supported player is \"audio\" or \"video\"');\r\n\r\n\t\telement = document.createElement(element);\r\n\t\tdocument.body.appendChild(element);\r\n\t}\r\n\r\n\tvar propertyLinker = ['autoplay', 'loop', 'buffered', 'buffered', 'controller', 'currentTime', 'currentSrc', 'duration', 'ended', 'error', 'readyState', 'networkState', 'paused', 'played', 'seekable', 'seeking'];\r\n\r\n\t// Get element audio for output node\r\n\tvar audioOutputNode = false;\r\n\tObject.defineProperty(self, 'audioOutput', {\r\n\t\tget: function(){\r\n\t\t\tif(!audioOutputNode)\r\n\t\t\t\taudioOutputNode = ScarletsMedia.getElementAudioNode(element);\r\n\r\n\t\t\treturn audioOutputNode;\r\n\t\t},\r\n\t\tenumerable: true\r\n\t});\r\n\r\n\tif(element.tagName.toLowerCase() === 'video'){\r\n\t\tpropertyLinker = propertyLinker.concat(['poster', 'height', 'width']);\r\n\r\n\t\t// Get element video for output node\r\n\t\tvar videoOutputNode = false;\r\n\t\tObject.defineProperty(self, 'videoOutput', {\r\n\t\t\tget: function(){\r\n\t\t\t\tif(!videoOutputNode)\r\n\t\t\t\t\tvideoOutputNode = ScarletsMedia.getElementVideoNode(element);\r\n\r\n\t\t\t\treturn videoOutputNode;\r\n\t\t\t},\r\n\t\t\tenumerable: true\r\n\t\t});\r\n\t}\r\n\r\n\t// Reference element function\r\n\tself.load = function(){\r\n\t\telement.load();\r\n\t}\r\n\r\n\tself.canPlayType = function(){\r\n\t\telement.canPlayType();\r\n\t}\r\n\r\n\t// Reference element property\r\n\tfor (var i = 0; i < propertyLinker.length; i++) {\r\n\t\tScarletsMedia.extra.objectPropertyLinker(self, element, propertyLinker[i]);\r\n\t}\r\n\r\n\tself.preload = true;\r\n\telement.preload = 'metadata';\r\n\telement.crossorigin = 'anonymous';\r\n\tself.audioFadeEffect = true;\r\n\r\n\tself.speed = function(set){\r\n\t\tif(set === undefined) return element.defaultPlaybackRate;\r\n\t\telement.defaultPlaybackRate = element.playbackRate = set;\r\n\t}\r\n\r\n\tself.mute = function(set){\r\n\t\tif(set === undefined) return element.muted;\r\n\t\telement.defaultMuted = element.muted = set;\r\n\t}\r\n\r\n\tself.stop = function(){\r\n\t\tself.pause();\r\n\t\tself.currentTime = 0;\r\n\t}\r\n\r\n\tvar volume = 1;\r\n\tself.volume = function(set){\r\n\t\tif(set === undefined) return volume;\r\n\t\telement.volume = volume = set;\r\n\t}\r\n\r\n\tvar stillWaiting = false;\r\n\tfunction play(successCallback, errorCallback){\r\n\t\telement.play().then(function(){\r\n\t\t\tstillWaiting = false;\r\n\t\t\tif(successCallback) successCallback();\r\n\t\t}).catch(function(e){\r\n\t\t\tif(errorCallback) errorCallback(e);\r\n\t\t\telse{\r\n\t\t\t\t// If user haven't interacted with the page\r\n\t\t\t\t// and media play was requested, let's pending it\r\n\t\t\t\tif(userInteracted === false){\r\n\t\t\t\t\tif(stillWaiting === false){\r\n\t\t\t\t\t\twaitingUnlock.push(function(){\r\n\t\t\t\t\t\t\tplay(successCallback, errorCallback);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.error(e);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tself.play = function(successCallback, errorCallback){\r\n\t\tif(!element.paused){\r\n\t\t\tif(successCallback) successCallback();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(self.audioFadeEffect){\r\n\t\t\telement.volume = 0;\r\n\t\t\tplay(successCallback, errorCallback);\r\n\t\t\tScarletsMedia.extra.fadeNumber(0, volume, 0.02, 400, function(num){\r\n\t\t\t\telement.volume = num;\r\n\t\t\t}, successCallback);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tplay(successCallback, errorCallback);\r\n\t}\r\n\r\n\tself.pause = function(callback){\r\n\t\tif(element.paused){\r\n\t\t\tif(callback) callback();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(self.audioFadeEffect){\r\n\t\t\tScarletsMedia.extra.fadeNumber(volume, 0, -0.02, 400, function(num){\r\n\t\t\t\telement.volume = num;\r\n\t\t\t}, function(){\r\n\t\t\t\telement.pause();\r\n\t\t\t\tif(callback) callback();\r\n\t\t\t});\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telement.pause();\r\n\t\tif(callback) callback();\r\n\t}\r\n\r\n\tself.prepare = function(links, callback, force){\r\n\t\t// Stop playing media\r\n\t\tif(!force && !element.paused)\r\n\t\t\treturn self.pause(function(){\r\n\t\t\t\tself.prepare(links, callback, true);\r\n\t\t\t});\r\n\r\n\t\tvar temp = element.querySelectorAll('source');\r\n\t\tfor (var i = temp.length - 1; i >= 0; i--) {\r\n\t\t\ttemp[i].remove();\r\n\t\t}\r\n\r\n\t\tif(self.preload && callback){\r\n\t\t\tself.once('canplay', callback);\r\n\t\t\tself.once('error', function(){\r\n\t\t\t\tself.off('canplay', callback);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(typeof links === 'string')\r\n\t\t\telement.insertAdjacentHTML('beforeend', `<source src=\"${links.split('\"').join('\\\\\"')}\"/>`);\r\n\t\telse{\r\n\t\t\ttemp = '';\r\n\t\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\t\ttemp += `<source src=\"${links[i].split('\"').join('\\\\\"')}\"/>`;\r\n\t\t\t}\r\n\t\t\telement.insertAdjacentHTML('beforeend', temp);\r\n\t\t}\r\n\r\n\t\t// Preload data\r\n\t\tif(self.preload)\r\n\t\t\telement.load();\r\n\r\n\t\telse if(callback)\r\n\t\t\tcallback();\r\n\t}\r\n\r\n\tvar eventRegistered = {};\r\n\tfunction eventTrigger(e){\r\n\t\tfor (var i = 0; i < eventRegistered[e.type].length; i++) {\r\n\t\t\teventRegistered[e.type][i](e, self);\r\n\t\t}\r\n\t}\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events\r\n\tself.on = function(eventName, callback){\r\n\t\tvar name = eventName.toLowerCase();\r\n\t\tif(eventRegistered[name] === undefined){\r\n\t\t\telement.addEventListener(eventName, eventTrigger, true);\r\n\t\t\teventRegistered[name] = [];\r\n\t\t}\r\n\t\teventRegistered[name].push(callback);\r\n\t\treturn self;\r\n\t}\r\n\r\n\tself.off = function(eventName, callback){\r\n\t\tvar name = eventName.toLowerCase();\r\n\t\tif(eventRegistered[name] === undefined){\r\n\t\t\telement.removeEventListener(eventName, callback, true);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(!callback)\r\n\t\t\teventRegistered[name].splice(0);\r\n\t\telse\r\n\t\t\teventRegistered[name].splice(eventRegistered[name].indexOf(callback), 1);\r\n\r\n\t\tif(eventRegistered[name].length === 0){\r\n\t\t\teventRegistered[name] = undefined;\r\n\t\t\telement.removeEventListener(eventName, eventTrigger, true);\r\n\t\t}\r\n\t\treturn self;\r\n\t}\r\n\r\n\tself.once = function(eventName, callback){\r\n\t\telement.addEventListener(eventName, callback, {once:true});\r\n\t\treturn self;\r\n\t}\r\n\r\n\tself.destroy = function(){\r\n\t\tfor(var key in eventRegistered){\r\n\t\t\tself.off(key);\r\n\t\t}\r\n\t\tself.playlist.list.splice(0);\r\n\t\tself.playlist.original.splice(0);\r\n\t\tfor(var key in self){\r\n\t\t\tdelete self[key];\r\n\t\t}\r\n\t\tself = null;\r\n\r\n\t\telement.pause();\r\n\t\telement.innerHTML = '';\r\n\t}\r\n\r\n\tvar playlistInitialized = false;\r\n\tfunction internalPlaylistEvent(){\r\n\t\tif(playlistInitialized) return;\r\n\t\tplaylistInitialized = true;\r\n\r\n\t\tself.on('ended', function(){\r\n\t\t\tif(self.playlist.currentIndex < self.playlist.list.length - 1)\r\n\t\t\t\tself.playlist.next(true);\r\n\t\t\telse if(self.playlist.loop)\r\n\t\t\t\tself.playlist.play(0);\r\n\t\t});\r\n\t}\r\n\r\n\tfunction playlistTriggerEvent(name){\r\n\t\tif(!eventRegistered[name]) return;\r\n\t\tfor (var i = 0; i < eventRegistered[name].length; i++) {\r\n\t\t\teventRegistered[name][i](self, self.playlist, self.playlist.currentIndex);\r\n\t\t}\r\n\t}\r\n\r\n\tself.playlist = {\r\n\t\tcurrentIndex:0,\r\n\t\tlist:[],\r\n\t\toriginal:[],\r\n\t\tloop:false,\r\n\t\tshuffled:false,\r\n\r\n\t\t// lists = [{yourProperty:'', stream:['main.mp3', 'fallback.ogg', ..]}, ...]\r\n\t\treload(lists){\r\n\t\t\tthis.original = lists;\r\n\t\t\tthis.shuffle(this.shuffled);\r\n\t\t\tinternalPlaylistEvent();\r\n\t\t},\r\n\r\n\t\t// obj = {yourProperty:'', stream:['main.mp3', 'fallback.ogg']}\r\n\t\tadd(obj){\r\n\t\t\tthis.original.push(obj);\r\n\t\t\tthis.shuffle(this.shuffled);\r\n\t\t\tinternalPlaylistEvent();\r\n\t\t},\r\n\r\n\t\t// index from 'original' property\r\n\t\tremove(index){\r\n\t\t\tthis.original.splice(index, 1);\r\n\t\t\tthis.shuffle(this.shuffled);\r\n\t\t},\r\n\r\n\t\tnext(autoplay){\r\n\t\t\tthis.currentIndex++;\r\n\t\t\tif(this.currentIndex >= this.list.length){\r\n\t\t\t\tif(this.loop)\r\n\t\t\t\t\tthis.currentIndex = 0;\r\n\t\t\t\telse{\r\n\t\t\t\t\tthis.currentIndex--;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(autoplay)\r\n\t\t\t\tthis.play(this.currentIndex);\r\n\t\t\telse playlistTriggerEvent('playlistchange');\r\n\t\t},\r\n\r\n\t\tprevious(autoplay){\r\n\t\t\tthis.currentIndex--;\r\n\t\t\tif(this.currentIndex < 0){\r\n\t\t\t\tif(this.loop)\r\n\t\t\t\t\tthis.currentIndex = this.list.length - 1;\r\n\t\t\t\telse{\r\n\t\t\t\t\tthis.currentIndex++;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(autoplay)\r\n\t\t\t\tthis.play(this.currentIndex);\r\n\t\t\telse playlistTriggerEvent('playlistchange');\r\n\t\t},\r\n\r\n\t\tplay(index){\r\n\t\t\tthis.currentIndex = index;\r\n\t\t\tplaylistTriggerEvent('playlistchange');\r\n\r\n\t\t\tvar src = this.list[index].stream;\r\n\t\t\tif(self.currentSrc === src)\r\n\t\t\t\tself.play();\r\n\t\t\telse self.prepare(this.list[index].stream, function(){\r\n\t\t\t\tself.play();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tshuffle(set){\r\n\t\t\tif(set === true){\r\n\t\t\t    var j, x, i;\r\n\t\t\t    for (i = this.list.length - 1; i > 0; i--) {\r\n\t\t\t        j = Math.floor(Math.random() * (i + 1));\r\n\t\t\t        x = this.list[i];\r\n\t\t\t        this.list[i] = this.list[j];\r\n\t\t\t        this.list[j] = x;\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\telse this.list = this.original.slice(0);\r\n\r\n\t\t\tthis.shuffled = set;\r\n\t\t}\r\n\t};\r\n}","// options = mediaDevices.getUserMedia({thisData})\r\n// latency = 0ms is not possible (minimum is 70ms, or depend on computer performance)\r\nvar ScarletsMediaPresenter = function(options, latency){\r\n\tvar scope = this;\r\n\tif(!latency) latency = 1000;\r\n\r\n\t// The options are optional\r\n\t//var options = {\r\n\t//    mediaStream: new MediaStream(), // For custom media stream\r\n\t//    element: document.querySelector(...), // Record <audio>, <video>, <canvas>\r\n\t//    screen: true, // Recording the screen\r\n\t//\r\n\t//    audio:{\r\n\t//        channelCount:1,\r\n\t//        echoCancellation: false\r\n\t//    },\r\n\t//    video:{\r\n\t//        frameRate:15,\r\n\t//        width: 1280,\r\n\t//        height: 720,\r\n\t//        facingMode: (front ? \"user\" : \"environment\")\r\n\t//    }\r\n\t//};\r\n\r\n\tscope.debug = false;\r\n\tscope.mediaStream = false;\r\n\r\n\tscope.onRecordingReady = null;\r\n\tscope.onBufferProcess = null;\r\n\tscope.onStop = null;\r\n\r\n\tscope.mediaRecorder = null;\r\n\tscope.recordingReady = false;\r\n\r\n\tscope.recording = false;\r\n\tscope.mediaGranted = false;\r\n\r\n\tif(options === void 0)\r\n\t\toptions = {};\r\n\r\n\tif(options.element !== void 0)\r\n\t\toptions.mediaStream = options.element.captureStream();\r\n\r\n\tscope.debug = options.debug;\r\n\r\n\tscope.workerOptions = options.workerOptions;\r\n\t\r\n\t// Deprecated\r\n\tscope.options = options;\r\n\r\n\tvar mediaType = options.video ? 'video' : 'audio';\r\n\r\n\r\n\tlet MediaRecorder = window.MediaRecorder;\r\n\tlet usingOpusMediaRecorderPolyfill = false;\r\n\r\n\tif(window.OpusMediaRecorder) {\r\n\t\tif(options.alwaysUsePolyfill) {\r\n\t\t\tusingOpusMediaRecorderPolyfill = true;\r\n\t\t}\r\n\t\telse if(!window.MediaRecorder) {\r\n\t\t\tif (!options.mimeType) {\r\n\t\t\t\toptions.mimeType = 'audio/webm;codecs=opus'; // Preferred one\r\n\t\t\t}\r\n\t\t\tusingOpusMediaRecorderPolyfill = OpusMediaRecorder.isTypeSupported(options.mimeType);\r\n\t\t}\r\n\t\telse if(options.mimeType && MediaRecorder.isTypeSupported(options.mimeType)) {\r\n\t\t\tusingOpusMediaRecorderPolyfill = window.MediaRecorder === window.OpusMediaRecorder;\r\n\t\t}\r\n\t\telse if(options.mimeType) {\r\n\t\t\tusingOpusMediaRecorderPolyfill = OpusMediaRecorder.isTypeSupported(options.mimeType);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tusingOpusMediaRecorderPolyfill = window.MediaRecorder === window.OpusMediaRecorder;\r\n\t\t}\r\n\t\t\r\n\t\tif(usingOpusMediaRecorderPolyfill) {\r\n\t\t\tMediaRecorder = OpusMediaRecorder;\r\n\r\n\t\t\tif(mediaType === 'video') {\r\n\t\t\t\tconsole.log(\"opus-media-recorder does not support video recording.\");\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tif (!MediaRecorder) {\r\n\t\tthrow \"MediaRecorder is not available\";\r\n\t}\r\n\r\n\t// Check supported mimeType and codecs for the recorder\r\n\tif(options.mimeType && !MediaRecorder.isTypeSupported(options.mimeType)) {\r\n\t\tconsole.log(\"MediaRecorder doesn't supports mimetype \" + options.mimeType);\r\n\t\toptions.mimeType = null;\r\n\t}\r\n\r\n\tif(!options.mimeType){\r\n\t\tvar supportedMimeType = false;\r\n\t\tvar codecsList = mediaType === 'audio' ? audioCodecs : videoCodecs;\r\n\r\n\t\tfor(var format in codecsList){\r\n\t\t\tvar mimeType = mediaType+'/'+format;\r\n\t\t\tvar codecs = codecsList[format];\r\n\r\n\t\t\tfor (var i = 0; i < codecs.length; i++) {\r\n\t\t\t\tvar temp = mimeType+';codecs='+codecs[i];\r\n\t\t\t\tif(MediaRecorder.isTypeSupported(temp) && MediaSource.isTypeSupported(temp)){\r\n\t\t\t\t\tsupportedMimeType = temp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(supportedMimeType === false && MediaRecorder.isTypeSupported(mimeType) && MediaSource.isTypeSupported(mimeType))\r\n\t\t\t\tsupportedMimeType = mimeType;\r\n\r\n\t\t\tif(supportedMimeType !== false)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\toptions.mimeType = supportedMimeType;\r\n\r\n\t\tif (scope.debug) console.log(\"mimeType: \"+supportedMimeType);\r\n\t}\r\n\r\n\tvar mediaGranted = function(mediaStream) {\r\n\t\tscope.mediaGranted = true;\r\n\r\n\t\t// For adding effect later (if audio available)\r\n\t\tif(options.audio !== void 0){\r\n\t\t\tscope.source = ScarletsMedia.audioContext.createMediaStreamSource(mediaStream);\r\n\t\t\tscope.mediaStream = mediaStream = scope.destination.stream;\r\n\r\n\t\t\tif(pendingConnect.length !== 0){\r\n\t\t\t\tfor (var i = 0; i < pendingConnect.length; i++)\r\n\t\t\t\t\tscope.source.connect(pendingConnect[i]);\r\n\r\n\t\t\t\tfirstSourceConnect = false;\r\n\t\t\t\tpendingConnect.length = 0;\r\n\t\t\t}\r\n\t\t\telse scope.source.connect(scope.destination);\r\n\t\t}\r\n\r\n\t\tscope.bufferHeader = null;\r\n\t\tvar bufferHeaderLength = false;\r\n\r\n\t\tif(usingOpusMediaRecorderPolyfill) {\r\n\t\t\tscope.mediaRecorder = new MediaRecorder(mediaStream, options, scope.workerOptions);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tscope.mediaRecorder = new MediaRecorder(mediaStream, options);\r\n\t\t}\r\n\r\n\t\tif(scope.debug) console.log(\"MediaRecorder obtained\");\r\n\t\tscope.mediaRecorder.onstart = function(e) {\r\n\t\t\tscope.recording = true;\r\n\t\t};\r\n\r\n\t\tconst isVideo = options.video !== void 0;\r\n\t\tconst headerLatency = isVideo ? 565 : 100;\r\n\r\n\t\tscope.mediaRecorder.ondataavailable = function(e){\r\n\t\t\t// Stream segments after the header was obtained\r\n\t\t\tif (bufferHeaderLength !== false){\r\n\t\t\t\tvar streamingTime = Number(String(Date.now()).slice(-5, -3));\r\n\t\t\t\tscope.onBufferProcess([e.data, streamingTime]);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Return if the recording was stopped\r\n\t\t\tif(scope.mediaRecorder.state !== 'recording')\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(e.data.size <= 1) return;\r\n\r\n\t\t\t// The audio buffer can contain some duration that causes a noise\r\n\t\t\t// So we will need to remove it on streamer side\r\n\t\t\t// Because the AudioBuffer can't be converted to ArrayBuffer with WebAudioAPI\r\n\t\t\tscope.bufferHeader = e.data;\r\n\r\n\t\t\tvar predefinedBuffer = getBufferHeader(scope.mediaRecorder.mimeType);\r\n\t\t\tif(predefinedBuffer !== false)\r\n\t\t\t\tscope.bufferHeader = predefinedBuffer;\r\n\r\n\t\t\tbufferHeaderLength = scope.bufferHeader.size;\r\n\r\n\t\t\tif(bufferHeaderLength > 900 || bufferHeaderLength < 100)\r\n\t\t\t\tconsole.log('%c[WARN] The buffer header length was more than 0.9KB or smaller than 0.1KB. This sometime cause decode error on streamer side. Try to avoid any heavy CPU usage when using the recorder.', \"color:yellow\");\r\n\r\n\t\t\tif(scope.onRecordingReady)\r\n\t\t\t\tscope.onRecordingReady({\r\n\t\t\t\t\tmimeType:options.mimeType,\r\n\t\t\t\t\tstartTime:Date.now(),\r\n\t\t\t\t\thasVideo:isVideo,\r\n\t\t\t\t\tdata:scope.bufferHeader\r\n\t\t\t\t});\r\n\r\n\t\t\tscope.recordingReady = true;\r\n\r\n\t\t\tif(latency === headerLatency) return;\r\n\r\n\t\t\t// Record with the custom latency\r\n\t\t\tscope.mediaRecorder.stop();\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\tscope.mediaRecorder.start(latency);\r\n\t\t\t}, 10);\r\n\t\t};\r\n\r\n\t\t// Get first header\r\n\t\tscope.mediaRecorder.start(headerLatency);\r\n\t}\r\n\r\n\tvar pendingConnect = [];\r\n\r\n\tscope.source = void 0;\r\n\tscope.destination = ScarletsMedia.audioContext.createMediaStreamDestination();\r\n\r\n\tvar firstSourceConnect = true;\r\n\tscope.connect = function(node){\r\n\t\tif(scope.source === void 0){\r\n\t\t\tpendingConnect.push(node);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(firstSourceConnect){\r\n\t\t\ttry{\r\n\t\t\t\tscope.source.disconnect(scope.destination);\r\n\t\t\t}catch(e){}\r\n\r\n\t\t\tfirstSourceConnect = false;\r\n\t\t}\r\n\r\n\t\tscope.source.connect(node);\r\n\t}\r\n\r\n\tscope.disconnect = function(node){\r\n\t\tif(scope.source)\r\n\t\t\tscope.source.disconnect(node);\r\n\t\telse{\r\n\t\t\tvar i = pendingConnect.indexOf(node);\r\n\t\t\tif(i === -1)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tpendingConnect.splice(i, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reAddTracks(mediaStream) {\r\n\t\tvar streams = mediaStream.getTracks();\r\n\t\tfor(var i = 0; i < streams.length; i++)\r\n\t\t\tscope.mediaRecorder.stream.addTrack(streams[i]);\r\n\r\n\t\tscope.mediaRecorder.start(latency);\r\n\t\tscope.recording = true;\r\n\t}\r\n\r\n\tvar afterStop = false;\r\n\tscope.startRecording = function(){\r\n\t\tif(afterStop){\r\n\t\t\tafterStop = false;\r\n\r\n\t\t\tif(!options.mediaStream){ // Not custom\r\n\t\t\t\tif(!scope.options.screen) // Camera / Audio\r\n\t\t\t\t\tnavigator.mediaDevices.getUserMedia(options).then(reAddTracks).catch(console.error);\r\n\t\t\t\telse // Screen\r\n\t\t\t\t\tnavigator.mediaDevices.getDisplayMedia(options).then(reAddTracks).catch(console.error);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if(scope.mediaGranted === false || scope.mediaRecorder === null){\r\n\t\t\tscope.recordingReady = false;\r\n\r\n\t\t\tif(options.mediaStream) // Custom\r\n\t\t\t\tmediaGranted(options.mediaStream);\r\n\t\t\telse if(!scope.options.screen) // Camera / Audio\r\n\t\t\t\tnavigator.mediaDevices.getUserMedia(options).then(mediaGranted).catch(console.error);\r\n\t\t\telse // Screen\r\n\t\t\t\tnavigator.mediaDevices.getDisplayMedia(options).then(mediaGranted).catch(console.error);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(scope.mediaRecorder.state !== 'recording'){\r\n\t\t\tscope.mediaRecorder.start(latency);\r\n\t\t\tscope.recording = true;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tscope.stopRecording = function(){\r\n\t\tif (!scope.recording ||!scope.mediaRecorder) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tscope.recording = false;\r\n\t\tscope.mediaRecorder.stop();\r\n\r\n\t\tif(!options.mediaStream){\r\n\t\t\t// Turn off stream from microphone/camera\r\n\t\t\tvar streams = scope.mediaRecorder.stream.getTracks();\r\n\t\t\tfor(var i = 0; i < streams.length; i++){\r\n\t\t\t\tstreams[i].stop();\r\n\t\t\t\tscope.mediaRecorder.stream.removeTrack(streams[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// scope.mediaRecorder.ondataavailable = null;\r\n\t\t// scope.mediaRecorder.onstart = null;\r\n\r\n\t\tscope.bufferHeader = null;\r\n\r\n\t\tafterStop = true;\r\n\r\n\t\tif (scope.onStop) scope.onStop();\r\n\t};\r\n}\r\n\r\nScarletsMediaPresenter.isTypeSupported = function(mimeType){\r\n\tif(!MediaSource.isTypeSupported(mimeType))\r\n\t\treturn \"MediaSource is not supporting this type\";\r\n\tif(!MediaRecorder || !MediaRecorder.isTypeSupported(mimeType) || (window.OpusMediaRecorder && !window.OpusMediaRecorder.isTypeSupported(mimeType)))\r\n\t\treturn \"MediaRecorder is not supporting this type\";\r\n\treturn \"Maybe supported\";\r\n}\r\n","ScarletsMediaEffect.chorus = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar dry = context.createGain();\r\n    var wet = context.createGain();\r\n    var splitter = context.createChannelSplitter(2);\r\n    var merger = context.createChannelMerger(2);\r\n    sourceNode.connect(splitter);\r\n    sourceNode.connect(dry);\r\n\r\n    var channel = [{/* left */}, {/* right */}];\r\n\r\n    for (var i = 0; i < channel.length; i++) {\r\n    \tvar c = channel[i];\r\n\r\n    \t// Declaration\r\n    \tc.stream = context.createGain();\r\n    \tc.delayVibrato = context.createDelay();\r\n    \tc.delayFixed = context.createDelay();\r\n    \tc.feedback = context.createGain();\r\n    \tc.feedforward = context.createGain();\r\n    \tc.blend = context.createGain();\r\n\r\n    \t// Connection\r\n\t    splitter.connect(c.stream, i, 0);\r\n\t    c.stream.connect(c.delayVibrato);\r\n\t    c.stream.connect(c.delayFixed);\r\n\t    c.delayVibrato.connect(c.feedforward);\r\n\t    c.delayVibrato.connect(merger, 0, i);\r\n\t    c.delayFixed.connect(c.feedback);\r\n\t    c.feedback.connect(c.stream);\r\n\t    c.blend.connect(merger, 0, i);\r\n    }\r\n\r\n    // Output\r\n    merger.connect(wet);\r\n    dry.connect(output);\r\n    wet.connect(output);\r\n\r\n    // LFO modulation\r\n    var lfo = context.createOscillator();\r\n    var LDepth = context.createGain();\r\n    var RDepth = context.createGain();\r\n    lfo.connect(LDepth);\r\n    lfo.connect(RDepth);\r\n    LDepth.connect(channel[0].delayVibrato.delayTime);\r\n    RDepth.connect(channel[1].delayVibrato.delayTime);\r\n    lfo.start(0);\r\n\r\n    // Settings\r\n    lfo.type = 'sine';\r\n    lfo.frequency.value = 0.15;\r\n    LDepth.gain.value = 0.013;\r\n    RDepth.gain.value = -0.017;\r\n    channel[0].delayFixed.delayTime.value = 0.005;\r\n    channel[1].delayFixed.delayTime.value = 0.007;\r\n    channel[0].delayVibrato.delayTime.value = 0.013;\r\n    channel[1].delayVibrato.delayTime.value = 0.017;\r\n\r\n    var options = {rate:0, intensity:0, mix:0};\r\n\r\n\tvar ret =  {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\trate: function (value) { // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return options.rate;\r\n\t\t\toptions.rate = value;\r\n\r\n\t    \tvalue = value * 0.29 + 0.01;\r\n\t    \tlfo.frequency.value = value;\r\n\t    },\r\n\r\n\t    intensity: function (value) { // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return options.intensity;\r\n\t\t\toptions.intensity = value;\r\n\r\n\t    \tvar blend = 1.0 - (value * 0.2929);\r\n\t    \tvar feedforward = value * 0.2929 + 0.7071;\r\n\t    \tvar feedback = value * 0.7071;\r\n\r\n\t    \tfor (var i = 0; i < channel.length; i++) {\r\n\t\t    \tchannel[i].blend.gain.value = blend;\r\n\t\t    \tchannel[i].feedforward.gain.value = feedforward;\r\n\t\t    \tchannel[i].feedback.gain.value = feedback;\r\n\t    \t}\r\n\t    },\r\n\r\n\t    mix: function (value) {\r\n\t\t\tif(value === undefined) return options.mix;\r\n\t\t\toptions.mix = value;\r\n\t\t\t\r\n\t    \tdry.gain.value = value;\r\n\t    },\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tlfo.stop(0);\r\n\t\t\tlfo.disconnect();\r\n\t\t\t\r\n\t    \tfor (var i = 0; i < channel.length; i++) {\r\n\t\t    \tchannel[i].stream.disconnect();\r\n\t    \t}\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n\t// Initial settings\r\n    ret.rate(0.5);\r\n    ret.intensity(0.0);\r\n    ret.mix(0.75);\r\n\r\n\treturn ret;\r\n};","ScarletsMediaEffect.conReverb = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n    var reverbNode = context.createConvolver();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar dryGainNode = context.createGain();\r\n\r\n\tsourceNode.connect(dryGainNode);\r\n\tsourceNode.connect(reverbNode);\r\n\r\n    reverbNode.connect(wetGainNode);\r\n    dryGainNode.connect(output);\r\n    wetGainNode.connect(output);\r\n\r\n    function setBuffer(buffer){\r\n    \tif(reverbNode.buffer !== null){\r\n    \t\treverbNode.disconnect();\r\n    \t\treverbNode = context.createConvolver();\r\n\r\n\t\t\tsourceNode.connect(reverbNode);\r\n\t\t    reverbNode.connect(wetGainNode);\r\n    \t}\r\n    \treverbNode.buffer = buffer;\r\n    }\r\n\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\t// This must be set\r\n\t\tsetBuffer:setBuffer,\r\n\r\n\t\t// Load audio buffer from url\r\n\t\tloadBuffer:function(url){\r\n\t\t\tvar ajaxRequest = new XMLHttpRequest();\r\n\t\t\tajaxRequest.open('GET', url, true);\r\n\t\t\tajaxRequest.responseType = 'arraybuffer';\r\n\r\n\t\t\tajaxRequest.onload = function(){\r\n\t\t\t  var audioData = ajaxRequest.response;\r\n\t\t\t  context.decodeAudioData(audioData, function(buffer) {\r\n\t\t\t      setBuffer(buffer);\r\n\t\t\t  }, function(e){\"Error with decoding audio data\" + e.err});\r\n\t\t\t}\r\n\r\n\t\t\tajaxRequest.send();\r\n\t\t},\r\n\r\n\t\tmix: function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\treverbNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.cutOff = function(passType, sourceNode){ // passType: 'lowpass' | 'bandpass' | 'highpass'\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar filterNode = context.createBiquadFilter();\r\n\tfilterNode.type = passType || 'lowpass';\r\n\tfilterNode.frequency.value = 350;\r\n\tfilterNode.Q.value = 1;\r\n\tfilterNode.connect(output);\r\n\tsourceNode.connect(filterNode);\r\n\t\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\t\t\r\n\t\ttype: function(value){\r\n\t\t\tif(value === undefined)\r\n\t\t\t\treturn filterNode.type;\r\n\t\t\tfilterNode.type = value;\r\n\t\t},\r\n\t\tfrequency: function(value){\r\n\t\t\tif(value === undefined)\r\n\t\t\t\treturn filterNode.frequency.value;\r\n\t\t\tfilterNode.frequency.value = value;\r\n\t\t},\r\n\t\twidth: function(value){\r\n\t\t\tif(value === undefined)\r\n\t\t\t\treturn filterNode.Q.value;\r\n\t\t\tfilterNode.Q.value = value;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\tfilterNode.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.delay = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar dryGainNode = context.createGain();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar feedbackGainNode = context.createGain();\r\n\tvar delayNode = context.createDelay();\r\n\r\n\tsourceNode.connect(dryGainNode);\r\n\tdryGainNode.connect(output);\r\n\r\n\tdelayNode.connect(feedbackGainNode);\r\n\tfeedbackGainNode.connect(delayNode);\r\n\r\n\tsourceNode.connect(delayNode);\r\n\tdelayNode.connect(wetGainNode);\r\n\t\r\n\twetGainNode.connect(output);\r\n\t\r\n\tvar ret = {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tmix:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\t\ttime:function(value){ // value: 0 ~ 180\r\n\t\t\tif(value === undefined) return delayNode.delayTime.value;\r\n\t\t\tdelayNode.delayTime.value = value;\r\n\t\t},\r\n\t\tfeedback:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return feedbackGainNode.gain.value;\r\n\t\t\tfeedbackGainNode.gain.value = value;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\t\t\twetGainNode.disconnect();\r\n\t\t\tfeedbackGainNode.disconnect();\r\n\t\t\tdelayNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n\tret.mix(0.5);\r\n\tret.time(0.3);\r\n\tret.feedback(0.5);\r\n\r\n\treturn ret;\r\n};","ScarletsMediaEffect.distortion = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\tvar deg = 57 * Math.PI / 180;\r\n\r\n\tvar waveShaperNode = context.createWaveShaper();\r\n\twaveShaperNode.connect(output);\r\n\tsourceNode.connect(waveShaperNode);\r\n\r\n\tvar options = {\r\n\t\tamount:0\r\n\t};\r\n\treturn {\r\n\t\tset:function(amount){ // amount: 0 ~ 1\r\n\t\t\tif(amount === undefined) return options.amount;\r\n\t\t\toptions.amount = amount;\r\n\t\t\t\r\n\t\t\tamount = amount * 10;\r\n\t\t    var curve = new Float32Array(context.sampleRate);\r\n\t\t    var temp = 2 / context.sampleRate;\r\n\r\n\t\t    for (var i = 0 ; i < context.sampleRate; i++) {\r\n\t\t    \tvar x = i * temp - 1;\r\n\r\n\t\t    \t// http://kevincennis.github.io/transfergraph/\r\n\t\t    \tcurve[i] = (3 + amount) * x * deg / (Math.PI + amount * Math.abs(x));\r\n\t\t    }\r\n\r\n\t\t    waveShaperNode.curve = curve;\r\n\t\t},\r\n\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\twaveShaperNode.disconnect();\r\n\t\t\toutput.disconnect();\r\n\r\n\t\t\twaveShaperNode = output = null;\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.dubDelay = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar dryGainNode = context.createGain();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar feedbackGainNode = context.createGain();\r\n\tvar delayNode = context.createDelay();\r\n\tvar bqFilterNode = context.createBiquadFilter(); \r\n\r\n\tsourceNode.connect(dryGainNode);\r\n\tdryGainNode.connect(output);\r\n\r\n\tsourceNode.connect(wetGainNode);\r\n\tsourceNode.connect(feedbackGainNode);\r\n\r\n\tfeedbackGainNode.connect(bqFilterNode);\r\n\tbqFilterNode.connect(delayNode);\r\n\tdelayNode.connect(feedbackGainNode);\r\n\tdelayNode.connect(wetGainNode);\r\n\r\n\twetGainNode.connect(output);\r\n\t\r\n\tvar ret = {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\t\t\r\n\t\tmix:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\t\ttime:function(value){ // value: 0 ~ 180\r\n\t\t\tif(value === undefined) return delayNode.delayTime.value;\r\n\t\t\tdelayNode.delayTime.value = value;\r\n\t\t},\r\n\t\tfeedback:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return feedbackGainNode.gain.value;\r\n\t\t\tfeedbackGainNode.gain.value = value;\r\n\t\t},\r\n\t\tcutoff:function(value){ // value: 0 ~ 4000\r\n\t\t\tif(value === undefined) return bqFilterNode.frequency.value;\r\n\t\t\tbqFilterNode.frequency.value = value;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\t\t\twetGainNode.disconnect();\r\n\t\t\tfeedbackGainNode.disconnect();\r\n\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n\tret.mix(0.5);\r\n\tret.time(0.7);\r\n\tret.feedback(0.6);\r\n\tret.cutoff(700);\r\n\r\n\treturn ret;\r\n};","ScarletsMediaEffect.equalizer = function(frequencies, sourceNode){\r\n\tvar freq = frequencies || [32, 64, 125, 250, 500, 1000, 2000, 4000, 8000, 16000];\r\n\tvar context = ScarletsMedia.audioContext;\r\n\t\r\n\tvar output = context.createGain(); // Combine all effect\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar equalizer = {};\r\n\tvar lastIndex = freq.length - 1;\r\n\r\n\tfor (var i = 0; i < freq.length; i++) {\r\n        var filter = context.createBiquadFilter(); // Frequency pass\r\n\t\tfilter.gain.value = 0;\r\n        filter.frequency.value = freq[i];\r\n\r\n        if(i === 0) filter.type = 'lowshelf';\r\n        else if(i === lastIndex) filter.type = 'highshelf';\r\n        else filter.type = 'peaking';\r\n\r\n\t\tif(i !== 0)\r\n\t    \tequalizer[freq[i - 1]].connect(filter);\r\n        equalizer[freq[i]] = filter;\r\n\t}\r\n\r\n\tsourceNode.connect(equalizer[freq[0]]);\r\n\tfilter.connect(output);\r\n\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\t\t\r\n\t\tfrequency:function(frequency, dB){ // value: -20 ~ 20\r\n\t\t\tif(dB === undefined) return equalizer[frequency].gain.value;\r\n\t\t\tequalizer[frequency].gain.value = dB;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tfor (var i = 0; i < freq.length; i++) {\r\n\t    \t\tequalizer[freq[i]].disconnect(); // filter\r\n\t\t\t}\r\n\t\t\tequalizer.splice(0);\r\n\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\tequalizer = output = null;\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.fade = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\toutput.gain.value = 1;\r\n\tsourceNode.connect(output);\r\n\t\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tin:function(value, time, callback){ // value: 0~1, time: in seconds\r\n\t\t\toutput.gain.cancelScheduledValues(context.currentTime);\r\n\r\n\t\t\tvar remainingTime = (1 - output.gain.value) * value;\r\n\t\t\toutput.gain.setTargetAtTime(1.0, context.currentTime, remainingTime * time);\r\n\r\n\t\t\tif(callback) setTimeout(callback, time * 1000);\r\n\t\t},\r\n\t\tout:function(value, time, callback){ // value: 0~1, time: in seconds\r\n\t\t\toutput.gain.cancelScheduledValues(context.currentTime);\r\n\r\n\t\t\tvar remainingTime = output.gain.value * value;\r\n\t\t\toutput.gain.setTargetAtTime(0.00001, context.currentTime, remainingTime / time);\r\n\r\n\t\t\tif(callback) setTimeout(callback, time * 1000);\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.flanger = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar inputFeedbackNode = context.createGain();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar dryGainNode = context.createGain();\r\n\tvar delayNode = context.createDelay();\r\n\tvar oscillatorNode = context.createOscillator();\r\n\tvar gainNode = context.createGain();\r\n\tvar feedbackNode = context.createGain();\r\n\toscillatorNode.type = 'sine';\r\n\r\n\tsourceNode.connect(inputFeedbackNode);\r\n\tsourceNode.connect(dryGainNode);\r\n\r\n\tinputFeedbackNode.connect(delayNode);\r\n\tinputFeedbackNode.connect(wetGainNode);\r\n\r\n\tdelayNode.connect(wetGainNode);\r\n\tdelayNode.connect(feedbackNode);\r\n\r\n\tfeedbackNode.connect(inputFeedbackNode);\r\n\r\n\toscillatorNode.connect(gainNode);\r\n\tgainNode.connect(delayNode.delayTime);\r\n\r\n\tdryGainNode.connect(output);\r\n\twetGainNode.connect(output);\r\n\r\n\toscillatorNode.start(0);\r\n\t\r\n\tvar ret = {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tmix: function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\t\ttime:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return ScarletsMedia.extra.denormalize(delayNode.delayTime.value, 0.001, 0.02);\r\n\t\t\tdelayNode.delayTime.value = ScarletsMedia.extra.normalize(value, 0.001, 0.02);\r\n\t\t},\r\n\t\tspeed:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return ScarletsMedia.extra.denormalize(delayNode.delayTime.value, 0.5, 5);\r\n\t\t\toscillatorNode.frequency.value = ScarletsMedia.extra.normalize(value, 0.5, 5);\r\n\t\t},\r\n\t\tdepth:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return ScarletsMedia.extra.denormalize(delayNode.delayTime.value, 0.0005, 0.005);\r\n\t\t\tgainNode.gain.value = ScarletsMedia.extra.normalize(value, 0.0005, 0.005);\r\n\t\t},\r\n\t\tfeedback:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return ScarletsMedia.extra.denormalize(delayNode.delayTime.value, 0, 0.8);\r\n\t\t\tfeedbackNode.gain.value = ScarletsMedia.extra.normalize(value, 0, 0.8);\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tinputFeedbackNode.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n\tret.time(0.45);\r\n\tret.speed(0.2);\r\n\tret.depth(0.1);\r\n\tret.feedback(0.1);\r\n\tret.mix(0.5);\r\n\r\n\treturn ret;\r\n};","ScarletsMediaEffect.harmonizer = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n  \tvar bands = 8;\r\n\r\n\t// Cascading 2 filters for sharp resonance.\r\n    var filters1 = [];\r\n    var filters2 = [];\r\n    var gains = [];\r\n\r\n    for (var i = 0; i < bands; i++) {\r\n      filters1[i] = context.createBiquadFilter();\r\n      filters1[i].type = 'bandpass';\r\n      filters2[i] = context.createBiquadFilter();\r\n      filters2[i].type = 'bandpass';\r\n      sourceNode.connect(filters1[i]);\r\n\r\n      gains[i] = context.createGain();\r\n      gains[i].connect(output);\r\n      filters1[i].connect(filters2[i]).connect(gains[i]);\r\n    }\r\n\r\n    output.gain.value = 35.0;\r\n    var options = {\r\n    \tpitch:0,\r\n    \tslope:0,\r\n    \twidth:0\r\n    };\r\n\r\n\tvar ret = {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\t\t\r\n\t\t// Change frequency of filters\r\n\t    pitch: function (value) {\r\n\t\t\tif(value === undefined) return options.pitch;\r\n\t\t\toptions.pitch = value;\r\n\t\t\t\r\n\t    \tvar f0 = ScarletsMedia.convert.midiToFreq(value);\r\n\t    \tfor (var i = 0; i < bands; i++) {\r\n\t    \t\tfilters1[i].frequency.value = f0;\r\n\t    \t\tfilters2[i].frequency.value = f0;\r\n\t    \t}\r\n\t    },\r\n\r\n\t    slope: function (value) {\r\n\t\t\tif(value === undefined) return options.slope;\r\n\t\t\toptions.slope = value;\r\n\t\t\t\r\n\t    \tfor (var i = 0; i < bands; i++) {\r\n\t    \t\tgains[i].gain.value = 1.0 + Math.sin(Math.PI + (Math.PI/2 * (value + i / bands)));\r\n\t    \t}\r\n\t    },\r\n\r\n\t    width: function (value) {\r\n\t\t\tif(value === undefined) return options.width;\r\n\t\t\toptions.width = value;\r\n\t\t\t\r\n\t    \tfor (var i = 1; i < bands; i++) {\r\n\t    \t\tvar q = 2 + 90 * Math.pow((1 - i / bands), value);\r\n\t    \t\tfilters1[i].Q.value = q;\r\n\t    \t\tfilters2[i].Q.value = q;\r\n\t    \t}\r\n\t    },\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\r\n\t\t    for (var i = 0; i < bands; i++) {\r\n\t\t        filters1[i].disconnect();\r\n\t\t  \t}\r\n\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n    ret.pitch(34);\r\n    ret.slope(0.65);\r\n    ret.width(0.15);\r\n\r\n\treturn ret;\r\n\r\n\t// sample\r\n\t// noise x0.25 -> harmonizer -> reverb x0.85\r\n};","ScarletsMediaEffect.noise = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar length = Math.floor(context.sampleRate * 9.73);\r\n\tvar noiseFloat32 = new Float32Array(length);\r\n\r\n\tfor (var i = 0; i < length; i++) {\r\n\t\tnoiseFloat32[i] = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random()) * 0.5;\r\n\t}\r\n\r\n\tvar noiseBuffer = context.createBuffer(2, length, context.sampleRate);\r\n\tnoiseBuffer.getChannelData(0).set(noiseFloat32, 0);\r\n\tnoiseBuffer.getChannelData(1).set(noiseFloat32, 0);\r\n\r\n    var src = context.createBufferSource();\r\n    src.to(output);\r\n    src.loop = true;\r\n    src.start(0);\r\n    src.buffer = noiseBuffer;\r\n    src.loopStart = Math.random() * 9.73;\r\n\t\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tsrc.loop = false;\r\n\t\t\tsrc.buffer = null;\r\n    \t\tsrc.stop(0);\r\n\t\t\tsrc.disconnect();\r\n\t\t\tsrc = null;\r\n\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n};\r\n","ScarletsMediaEffect.pingPongDelay = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\tvar mix = 0;\r\n\r\n\tvar delayNodeLeft = context.createDelay();\r\n\tvar delayNodeRight = context.createDelay();\r\n\tvar dryGainNode = context.createGain();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar feedbackGainNode = context.createGain();\r\n\tvar channelMerger = context.createChannelMerger(2);\r\n\r\n\tsourceNode.connect(dryGainNode);\r\n\tdryGainNode.connect(output);\r\n\r\n\tdelayNodeLeft.connect(channelMerger, 0, 0);\r\n\tdelayNodeRight.connect(channelMerger, 0, 1);\r\n\tdelayNodeLeft.connect(delayNodeRight);\r\n\r\n\tfeedbackGainNode.connect(delayNodeLeft);\r\n\tdelayNodeRight.connect(feedbackGainNode);\r\n\r\n\tsourceNode.connect(feedbackGainNode);\r\n\r\n\tchannelMerger.connect(wetGainNode);\r\n\twetGainNode.connect(output);\r\n\t\r\n\tvar ret = {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tmix: function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\t\ttime:function(value){ // value: 0 ~ 180\r\n\t\t\tif(value === undefined) return delayNodeLeft.delayTime.value;\r\n\t\t\tdelayNodeLeft.delayTime.value = value;\r\n\t\t\tdelayNodeRight.delayTime.value = value;\r\n\t\t},\r\n\t\tfeedback:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return feedbackGainNode.gain.value;\r\n\t\t\tfeedbackGainNode.gain.value = value;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\t\t\tfeedbackGainNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n\tret.mix(0.5);\r\n\tret.time(0.3);\r\n\tret.feedback(0.5);\r\n\r\n\treturn ret;\r\n};","ScarletsMediaEffect.pitchShift = function(sourceNode){\r\n    var context = ScarletsMedia.audioContext;\r\n    var output = context.createGain();\r\n    var input = sourceNode === undefined ? context.createGain() : null;\r\n    if(input) sourceNode = input;\r\n\r\n    var bufferTime = 0.100;\r\n    var fadeTime = bufferTime / 2;\r\n    var bufferRate = bufferTime * context.sampleRate;\r\n\r\n    // Delay amount for changing pitch.\r\n    var modulateGain1 = context.createGain();\r\n    var modulateGain2 = context.createGain();\r\n\r\n    var delayNode1 = context.createDelay();\r\n    var delayNode2 = context.createDelay();\r\n    modulateGain1.connect(delayNode1.delayTime);\r\n    modulateGain2.connect(delayNode2.delayTime);\r\n\r\n    sourceNode.connect(delayNode1);\r\n    sourceNode.connect(delayNode2);\r\n\r\n    var fTime = context.currentTime + fadeTime;\r\n    var bTime = context.currentTime + bufferTime;\r\n\r\n    function createPitchBuffer(shiftUp){\r\n        var buffer = context.createBuffer(1, bufferRate, context.sampleRate);\r\n        var pitch = buffer.getChannelData(0);\r\n        \r\n        // Buffer pitch shift\r\n        for (var i = 0; i < bufferRate; i++) {\r\n            if(shiftUp)\r\n              pitch[i] = (bufferRate - i) / bufferRate;\r\n            else\r\n              pitch[i] = i / bufferRate;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n    \r\n    // Delay modulation.\r\n    var bufferSource = [0,0,0,0];\r\n    var bufferGain = [0,0,0,0];\r\n    for (var i = 0; i < bufferSource.length; i++) {\r\n        bufferSource[i] = context.createBufferSource();\r\n        bufferSource[i].loop = true;\r\n\r\n        bufferGain[i] = context.createGain();\r\n\r\n        if(i < 2)\r\n            bufferSource[i].buffer = createPitchBuffer(false);\r\n        else {\r\n            bufferSource[i].buffer = createPitchBuffer(true);\r\n            bufferGain[i].gain.value = 0;\r\n        }\r\n\r\n        if(i % 2){ // Odd\r\n            bufferGain[i].connect(modulateGain2);\r\n\t    \tbufferSource[i].start(bTime);\r\n        }\r\n        else { // Even\r\n            bufferGain[i].connect(modulateGain1);\r\n\t    \tbufferSource[i].start(fTime);\r\n        }\r\n\r\n        bufferSource[i].connect(bufferGain[i]);\r\n    }\r\n\r\n    function createPitchFadeBuffer(){\r\n        var buffer = context.createBuffer(1, bufferRate, context.sampleRate);\r\n        var pitch = buffer.getChannelData(0);\r\n            \r\n        var fadeLength = fadeTime * context.sampleRate;\r\n        var bufferLeft = bufferRate - fadeLength;\r\n        \r\n        // Buffer pitch shift\r\n        for (var i = 0; i < bufferRate; i++) {\r\n            if (i < fadeLength)\r\n                pitch[i] = Math.sqrt(i / fadeLength);\r\n            else\r\n                pitch[i] = Math.sqrt(1 - (i - bufferLeft) / fadeLength);\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    var fadeBuffer = createPitchFadeBuffer();\r\n\r\n    // Delay modulation.\r\n    var fadeNode = [0,0];\r\n    var mixNode = [0,0];\r\n    for (var i = 0; i < fadeNode.length; i++) {\r\n        fadeNode[i] = context.createBufferSource();\r\n        fadeNode[i].loop = true;\r\n        fadeNode[i].buffer = fadeBuffer;\r\n\r\n        mixNode[i] = context.createGain();\r\n    \tmixNode[i].gain.value = 0;\r\n        fadeNode[i].connect(mixNode[i].gain);\r\n\r\n        if(i % 2){ // Odd\r\n            bufferGain[i].connect(modulateGain2);\r\n\t    \tfadeNode[i].start(bTime);\r\n        }\r\n        else { // Even\r\n            bufferGain[i].connect(modulateGain1);\r\n\t    \tfadeNode[i].start(fTime);\r\n        }\r\n\r\n        mixNode[i].connect(output);\r\n    }\r\n    \r\n    delayNode1.connect(mixNode[0]);\r\n    delayNode2.connect(mixNode[1]);\r\n\r\n    function pitchGain(value){\r\n\t    modulateGain1.gain.value = \r\n\t    modulateGain2.gain.value = 0.5 * bufferTime * Math.abs(value);\r\n    }\r\n\r\n    var ret = {\r\n        // Connect to output\r\n        // output.connect(context.destination);\r\n        output:output,\r\n        input:input,\r\n\r\n        // pitchNode:[modulateGain1, modulateGain2],\r\n\r\n        shift:function(value){ // -3 ~ 3\r\n            if(value === undefined) return;\r\n\r\n            var pitchUp = value > 0;\r\n\t\t    bufferGain[0].gain.value = \r\n\t\t    bufferGain[1].gain.value = pitchUp ? 0 : 1;\r\n\t\t    bufferGain[2].gain.value = \r\n\t\t    bufferGain[3].gain.value = pitchUp ? 1 : 0;\r\n\r\n\t\t    pitchGain(value);\r\n        },\r\n\r\n        // This should be executed to clean memory\r\n        destroy:function(){\r\n            if(input) input.disconnect();\r\n            output.disconnect();\r\n\r\n            for (var i = 0; i < fadeNode.length; i++) {\r\n            \tfadeNode[i].stop();\r\n            \tfadeNode[i].disconnect();\r\n            \tmixNode[i].disconnect();\r\n            }\r\n\r\n            for (var i = 0; i < bufferSource.length; i++) {\r\n            \tbufferSource[i].stop();\r\n            \tbufferSource[i].disconnect();\r\n            \tbufferGain[i].disconnect();\r\n            }\r\n\r\n            modulateGain1.disconnect();\r\n\t\t\tmodulateGain2.disconnect();\r\n\t\t\tdelayNode1.disconnect();\r\n\t\t\tdelayNode2.disconnect();\r\n            \r\n            for(var key in this){\r\n                delete this[key];\r\n            }\r\n            output = null;\r\n        }\r\n    };\r\n\r\n    pitchGain(0);\r\n    return ret;\r\n}","ScarletsMediaEffect.reverb = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\t\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar reverbNode = context.createConvolver();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar dryGainNode = context.createGain();\r\n\t\r\n\tsourceNode.connect(dryGainNode);\r\n\tdryGainNode.connect(output);\r\n\twetGainNode.connect(output);\r\n\r\n\tvar time = 1,\r\n\t\tdecay = 0.1,\r\n\t\treverse = false;\r\n\r\n\tfunction rebuildImpulse(){\r\n\t\tvar length = context.sampleRate * time;\r\n\t\tvar impulse = context.createBuffer(2, length, context.sampleRate);\r\n\t\tvar impulseL = impulse.getChannelData(0);\r\n\t\tvar impulseR = impulse.getChannelData(1);\r\n\r\n\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\tvar n = reverse ? length - i : i;\r\n\t\t\timpulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\r\n\t\t\timpulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\r\n\t\t}\r\n\r\n\t    reverbNode.disconnect();\r\n\r\n\t    reverbNode = context.createConvolver();\r\n\t    sourceNode.connect(reverbNode);\r\n\t    reverbNode.connect(wetGainNode);\r\n\r\n\t\treverbNode.buffer = impulse;\r\n\t}\r\n\trebuildImpulse();\r\n\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tmix: function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\r\n\t\ttime: function(value){ // value: 0 ~ 3\r\n\t\t\tif(value === undefined) return time;\r\n\t\t\ttime = value;\r\n\t\t\trebuildImpulse();\r\n\t\t},\r\n\r\n\t\tdecay: function(value){// value: 0 ~ 3\r\n\t\t\tif(value === undefined) return decay;\r\n\t\t\tdecay = value;\r\n\t\t\trebuildImpulse();\r\n\t\t},\r\n\r\n\t\treverse: function(value){ // value: bool\r\n\t\t\tif(value === undefined) return reverse;\r\n\t\t\treverse = value;\r\n\t\t\trebuildImpulse();\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\treverbNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.stereoPanner = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar stereoSupport = false;\r\n\tif(context.createStereoPanner){\r\n\t\tvar pannerNode = context.createStereoPanner();\r\n\t\tstereoSupport = true;\r\n\t}\r\n\telse {\r\n\t\tvar pannerNode = context.createPanner();\r\n\t\tpannerNode.type = 'equalpower';\r\n\t}\r\n\r\n\tsourceNode.connect(pannerNode);\r\n\tpannerNode.connect(output);\r\n\tpannerNode.pan.value = 0;\r\n\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tset:function(pan){ // pan: -1 ~ 1\r\n\t\t\tif(pan === undefined) return pannerNode.pan.value;\r\n\t\t\tif(stereoSupport)\r\n\t\t\t\tpannerNode.pan.value = pan;\r\n\t\t\telse pannerNode.setPosition(pan, 0, 1 - Math.abs(pan));\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tpannerNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = pannerNode = null;\r\n\t\t}\r\n\t};\r\n};","ScarletsMediaEffect.tremolo = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tvar dryGainNode = context.createGain();\r\n\tvar wetGainNode = context.createGain();\r\n\r\n\tvar tremoloGainNode = context.createGain();\r\n\ttremoloGainNode.gain.value = 0;\r\n\r\n\tvar shaperNode = context.createWaveShaper();\r\n\tshaperNode.curve = new Float32Array([0, 1]);\r\n\tshaperNode.connect(tremoloGainNode.gain);\r\n\r\n\tsourceNode.connect(dryGainNode);\r\n\tdryGainNode.connect(output);\r\n\r\n\tvar lfoNode = context.createOscillator();\r\n\tlfoNode.connect(shaperNode);\r\n\tlfoNode.type = 'sine';\r\n\tlfoNode.start(0);\r\n\r\n\tsourceNode.connect(tremoloGainNode);\r\n\ttremoloGainNode.connect(wetGainNode);\r\n\twetGainNode.connect(output);\r\n\r\n\tvar ret = {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\r\n\t\tmix: function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\t\tspeed:function(value){\r\n\t\t\tif(value === undefined) return ScarletsMedia.extra.denormalize(lfoNode.frequency.value, 0, 20);\r\n\t\t\tlfoNode.frequency.value = ScarletsMedia.extra.normalize(value, 0, 20);\r\n\t\t},\r\n\t\tdepth:function(value){\r\n\t\t\tif(value === undefined) return 1 - this.shaperNode.curve[0];\r\n\t\t\tshaperNode.curve = new Float32Array([1 - value, 1]);\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\t\t\tdryGainNode.disconnect();\r\n\t\t\ttremoloGainNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n\r\n\tret.speed(0.2);\r\n\tret.depth(1);\r\n\tret.mix(0.8);\r\n\r\n\treturn ret;\r\n};","ScarletsMediaEffect.vibrato = function(sourceNode){\r\n\tvar context = ScarletsMedia.audioContext;\r\n\tvar output = context.createGain();\r\n\tvar input = sourceNode === undefined ? context.createGain() : null;\r\n\tif(input) sourceNode = input;\r\n\r\n\tconsole.log(\"Vibrato was not finished yet\");\r\n\r\n    var delayNode = context.createDelay();\r\n\tvar wetGainNode = context.createGain();\r\n\tvar dryGainNode = context.createGain();\r\n    var lfoNode = context.createOscillator();\r\n    //var depthNode = context.createGain();\r\n\r\n\tsourceNode.connect(dryGainNode);\r\n\tdryGainNode.connect(output);\r\n\twetGainNode.connect(output);\r\n\r\n    delayNode.delayTime.value = 1;\r\n    //depthNode.gain.value = 1;\r\n    lfoNode.frequency.value = 3;\r\n    lfoNode.type = 'sine';\r\n    lfoNode.start(0);\r\n\r\n    lfoNode.connect(delayNode.delayTime);\r\n    //depthNode.connect(delayNode.delayTime);\r\n    sourceNode.connect(delayNode);\r\n    delayNode.connect(wetGainNode);\r\n\r\n\treturn {\r\n\t\t// Connect to output\r\n\t\t// output.connect(context.destination);\r\n\t\toutput:output,\r\n\t\tinput:input,\r\n\t\t\r\n\t\tmix:function(value){ // value: 0 ~ 1\r\n\t\t\tif(value === undefined) return wetGainNode.gain.value;\r\n\t\t\tdryGainNode.gain.value = 1 - value;\r\n\t\t\twetGainNode.gain.value = value;\r\n\t\t},\r\n\t\t\r\n\t\tdelay:function(value){\r\n\t\t\tif(value === undefined) return delayNode.delayTime.value;\r\n\t\t\tdelayNode.delayTime.value = value;\r\n\t\t},\r\n\t\t\r\n\t\tdepth:function(value){\r\n\t\t\tif(value === undefined) return depthNode.gain.value;\r\n\t\t\tdepthNode.gain.value = value;\r\n\t\t},\r\n\t\t\r\n\t\tspeed:function(value){\r\n\t\t\tif(value === undefined) return lfoNode.frequency.value;\r\n\t\t\tlfoNode.frequency.value = value;\r\n\t\t},\r\n\r\n\t\t// This should be executed to clean memory\r\n\t\tdestroy:function(){\r\n\t\t\tif(input) input.disconnect();\r\n\t\t\toutput.disconnect();\r\n\r\n    \t\tsourceNode.disconnect(delayNode);\r\n    \t\tsourceNode.disconnect(dryGainNode);\r\n\r\n\t\t\tlfoNode.stop();\r\n\t\t\tlfoNode.disconnect();\r\n\t\t\tdepthNode.disconnect();\r\n\t\t\t\r\n\t\t\tfor(var key in this){\r\n\t\t\t\tdelete this[key];\r\n\t\t\t}\r\n\t\t\toutput = null;\r\n\t\t}\r\n\t};\r\n};","// Minimum 3 bufferElement\r\nvar ScarletsVideoStreamer = function(videoElement, chunksDuration){\r\n\tif(!chunksDuration) chunksDuration = 1000;\r\n\tvar chunksSeconds = chunksDuration/1000;\r\n\r\n\tvar scope = this;\r\n\r\n\tscope.debug = false;\r\n\tscope.playing = false;\r\n\tscope.latency = 0;\r\n\tscope.mimeType = null;\r\n\r\n\tscope.audioContext = ScarletsMedia.audioContext;\r\n\tscope.outputNode = false; // Set this to a connectable Audio Node\r\n\r\n\t// If the outputNode is not set, then the audio will be outputted directly\r\n\tvar directAudioOutput = true;\r\n\r\n\tvar mediaBuffer = false;\r\n\tvar audioNode = scope.audioContext.createMediaElementSource(videoElement);\r\n\r\n\tvideoElement.addEventListener('error', function(e){\r\n\t\tconsole.error(e.target.error);\r\n\t});\r\n\r\n\tscope.audioConnect = function(node){\r\n\t\tif(directAudioOutput === true){\r\n\t\t\tdirectAudioOutput = false;\r\n\t\t\taudioNode.disconnect();\r\n\t\t}\r\n\r\n\t\tscope.outputNode = scope.audioContext.createGain();\r\n\t\tscope.outputNode.connect(node);\r\n\t\taudioNode.connect(node);\r\n\t}\r\n\r\n\tscope.audioDisconnect = function(){\r\n\t\toutputNode.disconnect();\r\n\t\tdirectAudioOutput = true;\r\n\r\n\t\taudioNode.disconnect();\r\n\t\taudioNode.connect(scope.audioContext.destination);\r\n\t}\r\n\r\n\tscope.stop = function(){\r\n\t\tmediaBuffer.stop();\r\n\t\tscope.playing = false;\r\n\t\tscope.buffering = false;\r\n\t}\r\n\r\n\tscope.setBufferHeader = function(packet){\r\n\t\tif(!packet || !packet.data)\r\n\t\t\treturn;\r\n\r\n\t\tvar arrayBuffer = packet.data;\r\n\t\tscope.mimeType = packet.mimeType;\r\n\r\n\t\tif(mediaBuffer !== false)\r\n\t\t\tmediaBuffer.stop();\r\n\t\telse audioNode.connect(scope.audioContext.destination);\r\n\r\n\t\tmediaBuffer = new MediaBuffer(scope.mimeType, chunksDuration, arrayBuffer);\r\n\r\n\t\tvideoElement.src = scope.objectURL = mediaBuffer.objectURL;\r\n\t}\r\n\r\n\tscope.playStream = function(){\r\n\t\tscope.playing = true;\r\n\t}\r\n\r\n\tscope.receiveBuffer = function(packet){\r\n\t\tif(scope.playing === false || !mediaBuffer.append) return;\r\n\r\n\t\tvar arrayBuffer = packet[0];\r\n\t\tvar streamingTime = packet[1];\r\n\r\n\t\tmediaBuffer.append(arrayBuffer);\r\n\r\n\t\tif(videoElement.paused)\r\n\t\t\tvideoElement.play();\r\n\r\n\t\tscope.latency = (Number(String(Date.now()).slice(-5, -3)) - streamingTime) + scope.audioContext.baseLatency + chunksSeconds;\r\n\t\tif(scope.debug) console.log(\"Total latency: \"+scope.latency);\r\n\t}\r\n}\r\n","ScarletsMedia.extra = new function(){\r\n\tvar self = this;\r\n\tself.isMobile = function(){\r\n\t    return /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(navigator.userAgent);\r\n\t}\r\n\r\n\tself.objectPropertyLinker = function(self, target, property){\r\n\t\tObject.defineProperty(self, property, {\r\n\t\t  get: function(){ return target[property]; },\r\n\t\t  set: function(value){ target[property] = value; },\r\n\t\t  enumerable: true,\r\n\t\t  configurable: true\r\n\t\t});\r\n\t}\r\n\r\n\tself.normalize = function(value, min, max){\r\n\t\treturn ((max - min) * value) + min;\r\n\t}\r\n\r\n\tself.denormalize = function(value, min, max){\r\n\t\treturn (value - min) / (max - min);\r\n\t}\r\n\r\n\tvar maxFade = 0;\r\n\tself.fadeNumber = function(from, to, increment, fadeTime, onIncrease, onFinish){\r\n\t\tmaxFade = 0;\r\n\t\tvar current = from;\r\n\t\tvar interval = fadeTime/(Math.abs(from-to)/Math.abs(increment));\r\n\t\tif(!interval || interval == Infinity){\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\tif(onIncrease) onIncrease(to);\r\n\t\t\t\tif(onFinish) onFinish();\r\n\t\t\t}, fadeTime);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar timer = setInterval(function(){\r\n\t\t\tif(maxFade>=100) clearInterval(timer);\r\n\t\t\tmaxFade++;\r\n\r\n\t\t\tcurrent = (current+increment)*1000;\r\n\t\t\tcurrent = Math.ceil(current)/1000;\r\n\r\n\t\t\t//Increasing and current is more than target\r\n\t\t\tif((increment >= 0 && (current >= to || from >= to))\r\n\t\t\t\t||\r\n\t\t\t//Decreasing and current is lower than target\r\n\t\t\t(increment <= 0 && (current <= to || from <= to))\r\n\t\t\t\t||\r\n\t\t\t//Infinity or Zero number\r\n\t\t\t(current == Infinity || !current))\r\n\t\t\t{\r\n\t\t\t\tclearInterval(timer);\r\n\t\t\t\tonIncrease(to);\r\n\t\t\t\tif(onFinish) onFinish();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(onIncrease) onIncrease(current);\r\n\t\t}, interval);\r\n\t}\r\n\r\n\t// ===== Precise Timer =====\r\n\t//\r\n\tvar timeout = [];\r\n\tvar timeoutIncrement = 0;\r\n\tself.preciseTimeout = function(func, miliseconds){\r\n\t\tvar now = Date.now();\r\n\t\ttimeoutIncrement++;\r\n\t\ttimeout.push({\r\n\t\t\tid:timeoutIncrement,\r\n\t\t\twhen:now+miliseconds,\r\n\t\t\tfunc:func,\r\n\r\n\t\t\t// When browser loss focus\r\n\t\t\tfallback:setTimeout(function(){\r\n\t\t\t\tclearPreciseTimer(timeoutIncrement).func();\r\n\t\t\t}, miliseconds)\r\n\t\t});\r\n\t\tstartPreciseTime();\r\n\t\treturn timeoutIncrement;\r\n\t}\r\n\tself.clearPreciseTimeout = function(id){\r\n\t\tclearPreciseTimer(id, timeout);\r\n\t}\r\n\r\n\tvar interval = [];\r\n\tvar intervalIncrement = 0;\r\n\tself.preciseInterval = function(func, miliseconds){\r\n\t\tvar now = Date.now();\r\n\t\tintervalIncrement++;\r\n\t\tvar temp = {\r\n\t\t\tid:intervalIncrement,\r\n\t\t\tinterval:miliseconds,\r\n\t\t\twhen:now+miliseconds,\r\n\t\t\tfunc:func\r\n\t\t};\r\n\r\n\t\t// When browser loss focus\r\n\t\ttemp.fallback = setInterval(function(){\r\n\t\t\tif(temp.when >= Date.now())\r\n\t\t\t\treturn; // Avoid multiple call\r\n\r\n\t\t\ttemp.when += temp.interval;\r\n\t\t\ttemp.func();\r\n\t\t}, miliseconds);\r\n\r\n\t\tinterval.push(temp);\r\n\t\tstartPreciseTime();\r\n\t\treturn intervalIncrement;\r\n\t}\r\n\tself.clearPreciseInterval = function(id){\r\n\t\tvar temp = clearPreciseTimer(id, interval);\r\n\t\tclearInterval(temp.fallback);\r\n\t}\r\n\r\n\tfunction clearPreciseTimer(id, list){\r\n\t\tfor (var i in list) {\r\n\t\t\tif(list[i].id === id)\r\n\t\t\t\treturn list.splice(i, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tvar preciseTimerStarted = false;\r\n\tfunction startPreciseTime(){\r\n\t\tif(preciseTimerStarted) return;\r\n\t\tpreciseTimerStarted = true;\r\n\r\n\t\tvar preciseTimer = function(){\r\n\t\t\tif(timeout.length === 0 && interval.length === 0){\r\n\t\t\t\tpreciseTimerStarted = false;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\trequestAnimationFrame(preciseTimer);\r\n\r\n\t\t\tvar currentTime = Date.now();\r\n\t\t\tfor (var i in timeout) {\r\n\t\t\t\tif(timeout[i].when < currentTime){\r\n\t\t\t\t\ttimeout[i].func();\r\n\t\t\t\t\tclearTimeout(timeout[i].fallback);\r\n\t\t\t\t\ttimeout.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i in interval) {\r\n\t\t\t\tif(interval[i].when < currentTime){\r\n\t\t\t\t\tinterval[i].func();\r\n\t\t\t\t\tinterval[i].when += interval[i].interval;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\trequestAnimationFrame(preciseTimer);\r\n\t}\r\n};\r\n\r\nif(moduleMode){\r\n\tglobal.Media = ScarletsMedia;\r\n\tglobal.MediaEffect = ScarletsMediaEffect;\r\n\tglobal.AudioStreamer = ScarletsAudioStreamer;\r\n\tglobal.VideoStreamer = ScarletsVideoStreamer;\r\n\tglobal.MediaPlayer = ScarletsMediaPlayer;\r\n\tglobal.MediaPresenter = ScarletsMediaPresenter;\r\n\tglobal.MediaBuffer = MediaBuffer;\r\n}\r\nelse{\r\n\tglobal.ScarletsMedia = ScarletsMedia;\r\n\tglobal.ScarletsMediaEffect = ScarletsMediaEffect;\r\n\tglobal.ScarletsAudioStreamer = ScarletsAudioStreamer;\r\n\tglobal.ScarletsVideoStreamer = ScarletsVideoStreamer;\r\n\tglobal.ScarletsMediaPlayer = ScarletsMediaPlayer;\r\n\tglobal.ScarletsMediaPresenter = ScarletsMediaPresenter;\r\n\tglobal.ScarletsMediaBuffer = MediaBuffer;\r\n}\r\n\r\n// ===== Module End =====\r\n})));"]},"metadata":{},"sourceType":"script"}