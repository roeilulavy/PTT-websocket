{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebUSBDevice = void 0;\n\nvar usb = require(\"../usb\");\n\nvar util_1 = require(\"util\");\n\nvar LIBUSB_TRANSFER_TYPE_MASK = 0x03;\nvar ENDPOINT_NUMBER_MASK = 0x7f;\nvar CLEAR_FEATURE = 0x01;\nvar ENDPOINT_HALT = 0x00;\n/**\n * Wrapper to make a node-usb device look like a webusb device\n */\n\nvar WebUSBDevice =\n/** @class */\nfunction () {\n  function WebUSBDevice(device) {\n    this.device = device;\n    this.configurations = [];\n    var usbVersion = this.decodeVersion(device.deviceDescriptor.bcdUSB);\n    this.usbVersionMajor = usbVersion.major;\n    this.usbVersionMinor = usbVersion.minor;\n    this.usbVersionSubminor = usbVersion.sub;\n    this.deviceClass = device.deviceDescriptor.bDeviceClass;\n    this.deviceSubclass = device.deviceDescriptor.bDeviceSubClass;\n    this.deviceProtocol = device.deviceDescriptor.bDeviceProtocol;\n    this.vendorId = device.deviceDescriptor.idVendor;\n    this.productId = device.deviceDescriptor.idProduct;\n    var deviceVersion = this.decodeVersion(device.deviceDescriptor.bcdDevice);\n    this.deviceVersionMajor = deviceVersion.major;\n    this.deviceVersionMinor = deviceVersion.minor;\n    this.deviceVersionSubminor = deviceVersion.sub;\n  }\n\n  WebUSBDevice.createInstance = function (device) {\n    return __awaiter(this, void 0, void 0, function () {\n      var instance, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n\n            instance = new WebUSBDevice(device);\n            return [4\n            /*yield*/\n            , instance.initialize()];\n\n          case 1:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , instance];\n\n          case 2:\n            _a = _b.sent();\n            return [2\n            /*return*/\n            , undefined];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(WebUSBDevice.prototype, \"configuration\", {\n    get: function () {\n      if (!this.device.configDescriptor) {\n        return undefined;\n      }\n\n      var currentConfiguration = this.device.configDescriptor.bConfigurationValue;\n      return this.configurations.find(function (configuration) {\n        return configuration.configurationValue === currentConfiguration;\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebUSBDevice.prototype, \"opened\", {\n    get: function () {\n      return !!this.device.interfaces;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebUSBDevice.prototype.open = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        try {\n          if (this.opened) {\n            return [2\n            /*return*/\n            ];\n          }\n\n          this.device.open();\n        } catch (error) {\n          throw new Error(\"open error: \" + error);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.close = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, _c, iface, e_1_1, _error_1, error_1;\n\n      var e_1, _d;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 12,, 13]);\n\n            if (!this.opened) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            _e.label = 1;\n\n          case 1:\n            _e.trys.push([1, 10,, 11]);\n\n            if (!this.configuration) return [3\n            /*break*/\n            , 9];\n            _e.label = 2;\n\n          case 2:\n            _e.trys.push([2, 7, 8, 9]);\n\n            _b = __values((_a = this.configuration) === null || _a === void 0 ? void 0 : _a.interfaces), _c = _b.next();\n            _e.label = 3;\n\n          case 3:\n            if (!!_c.done) return [3\n            /*break*/\n            , 6];\n            iface = _c.value;\n            return [4\n            /*yield*/\n            , this._releaseInterface(iface.interfaceNumber)];\n\n          case 4:\n            _e.sent(); // Re-create the USBInterface to set the claimed attribute\n\n\n            this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n              interfaceNumber: iface.interfaceNumber,\n              alternate: iface.alternate,\n              alternates: iface.alternates,\n              claimed: false\n            };\n            _e.label = 5;\n\n          case 5:\n            _c = _b.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 6:\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            e_1_1 = _e.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            try {\n              if (_c && !_c.done && (_d = _b.return)) _d.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [3\n            /*break*/\n            , 11];\n\n          case 10:\n            _error_1 = _e.sent();\n            return [3\n            /*break*/\n            , 11];\n\n          case 11:\n            this.device.close();\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            error_1 = _e.sent();\n            throw new Error(\"close error: \" + error_1);\n\n          case 13:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.selectConfiguration = function (configurationValue) {\n    return __awaiter(this, void 0, void 0, function () {\n      var config, setConfiguration, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.opened || !this.device.configDescriptor) {\n              throw new Error('selectConfiguration error: invalid state');\n            }\n\n            if (this.device.configDescriptor.bConfigurationValue === configurationValue) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            config = this.configurations.find(function (configuration) {\n              return configuration.configurationValue === configurationValue;\n            });\n\n            if (!config) {\n              throw new Error('selectConfiguration error: configuration not found');\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            setConfiguration = util_1.promisify(this.device.setConfiguration).bind(this.device);\n            return [4\n            /*yield*/\n            , setConfiguration(configurationValue)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_2 = _a.sent();\n            throw new Error(\"selectConfiguration error: \" + error_2);\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.claimInterface = function (interfaceNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var iface;\n      return __generator(this, function (_a) {\n        if (!this.opened) {\n          throw new Error('claimInterface error: invalid state');\n        }\n\n        if (!this.configuration) {\n          throw new Error('claimInterface error: interface not found');\n        }\n\n        iface = this.configuration.interfaces.find(function (usbInterface) {\n          return usbInterface.interfaceNumber === interfaceNumber;\n        });\n\n        if (!iface) {\n          throw new Error('claimInterface error: interface not found');\n        }\n\n        if (iface.claimed) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        try {\n          this.device.interface(interfaceNumber).claim(); // Re-create the USBInterface to set the claimed attribute\n\n          this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n            interfaceNumber: interfaceNumber,\n            alternate: iface.alternate,\n            alternates: iface.alternates,\n            claimed: true\n          };\n        } catch (error) {\n          throw new Error(\"claimInterface error: \" + error);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.releaseInterface = function (interfaceNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var iface;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._releaseInterface(interfaceNumber)];\n\n          case 1:\n            _a.sent();\n\n            if (this.configuration) {\n              iface = this.configuration.interfaces.find(function (usbInterface) {\n                return usbInterface.interfaceNumber === interfaceNumber;\n              });\n\n              if (iface) {\n                // Re-create the USBInterface to set the claimed attribute\n                this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n                  interfaceNumber: interfaceNumber,\n                  alternate: iface.alternate,\n                  alternates: iface.alternates,\n                  claimed: false\n                };\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.selectAlternateInterface = function (interfaceNumber, alternateSetting) {\n    return __awaiter(this, void 0, void 0, function () {\n      var iface, iface_1, setAltSetting, error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.opened) {\n              throw new Error('selectAlternateInterface error: invalid state');\n            }\n\n            if (!this.configuration) {\n              throw new Error('selectAlternateInterface error: interface not found');\n            }\n\n            iface = this.configuration.interfaces.find(function (usbInterface) {\n              return usbInterface.interfaceNumber === interfaceNumber;\n            });\n\n            if (!iface) {\n              throw new Error('selectAlternateInterface error: interface not found');\n            }\n\n            if (!iface.claimed) {\n              throw new Error('selectAlternateInterface error: invalid state');\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            iface_1 = this.device.interface(interfaceNumber);\n            setAltSetting = util_1.promisify(iface_1.setAltSetting).bind(iface_1);\n            return [4\n            /*yield*/\n            , setAltSetting(alternateSetting)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_3 = _a.sent();\n            throw new Error(\"selectAlternateInterface error: \" + error_3);\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.controlTransferIn = function (setup, length) {\n    return __awaiter(this, void 0, void 0, function () {\n      var type, controlTransfer, result, error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            type = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_IN);\n            controlTransfer = util_1.promisify(this.device.controlTransfer).bind(this.device);\n            return [4\n            /*yield*/\n            , controlTransfer(type, setup.request, setup.value, setup.index, length)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , {\n              data: result ? new DataView(new Uint8Array(result).buffer) : undefined,\n              status: 'ok'\n            }];\n\n          case 2:\n            error_4 = _a.sent();\n\n            if (error_4.errno === usb.LIBUSB_TRANSFER_STALL) {\n              return [2\n              /*return*/\n              , {\n                status: 'stall'\n              }];\n            }\n\n            if (error_4.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {\n              return [2\n              /*return*/\n              , {\n                status: 'babble'\n              }];\n            }\n\n            throw new Error(\"controlTransferIn error: \" + error_4);\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.controlTransferOut = function (setup, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var type, controlTransfer, buffer, bytesWritten, error_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            type = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_OUT);\n            controlTransfer = util_1.promisify(this.device.controlTransfer).bind(this.device);\n            buffer = data ? Buffer.from(data) : Buffer.alloc(0);\n            return [4\n            /*yield*/\n            , controlTransfer(type, setup.request, setup.value, setup.index, buffer)];\n\n          case 1:\n            bytesWritten = _a.sent();\n            return [2\n            /*return*/\n            , {\n              bytesWritten: bytesWritten,\n              status: 'ok'\n            }];\n\n          case 2:\n            error_5 = _a.sent();\n\n            if (error_5.errno === usb.LIBUSB_TRANSFER_STALL) {\n              return [2\n              /*return*/\n              , {\n                bytesWritten: 0,\n                status: 'stall'\n              }];\n            }\n\n            throw new Error(\"controlTransferOut error: \" + error_5);\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.clearHalt = function (direction, endpointNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var wIndex, controlTransfer, error_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            wIndex = endpointNumber | (direction === 'in' ? usb.LIBUSB_ENDPOINT_IN : usb.LIBUSB_ENDPOINT_OUT);\n            controlTransfer = util_1.promisify(this.device.controlTransfer).bind(this.device);\n            return [4\n            /*yield*/\n            , controlTransfer(usb.LIBUSB_RECIPIENT_ENDPOINT, CLEAR_FEATURE, ENDPOINT_HALT, wIndex, 0)];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_6 = _a.sent();\n            throw new Error(\"clearHalt error: \" + error_6);\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.transferIn = function (endpointNumber, length) {\n    return __awaiter(this, void 0, void 0, function () {\n      var endpoint, transfer, result, error_7;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            endpoint = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_IN);\n            transfer = util_1.promisify(endpoint.transfer).bind(endpoint);\n            return [4\n            /*yield*/\n            , transfer(length)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , {\n              data: result ? new DataView(new Uint8Array(result).buffer) : undefined,\n              status: 'ok'\n            }];\n\n          case 2:\n            error_7 = _a.sent();\n\n            if (error_7.errno === usb.LIBUSB_TRANSFER_STALL) {\n              return [2\n              /*return*/\n              , {\n                status: 'stall'\n              }];\n            }\n\n            if (error_7.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {\n              return [2\n              /*return*/\n              , {\n                status: 'babble'\n              }];\n            }\n\n            throw new Error(\"transferIn error: \" + error_7);\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.transferOut = function (endpointNumber, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var endpoint, transfer, buffer, bytesWritten, error_8;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            endpoint = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_OUT);\n            transfer = util_1.promisify(endpoint.transfer).bind(endpoint);\n            buffer = Buffer.from(data);\n            return [4\n            /*yield*/\n            , transfer(buffer)];\n\n          case 1:\n            bytesWritten = _a.sent();\n            return [2\n            /*return*/\n            , {\n              bytesWritten: bytesWritten,\n              status: 'ok'\n            }];\n\n          case 2:\n            error_8 = _a.sent();\n\n            if (error_8.errno === usb.LIBUSB_TRANSFER_STALL) {\n              return [2\n              /*return*/\n              , {\n                bytesWritten: 0,\n                status: 'stall'\n              }];\n            }\n\n            throw new Error(\"transferOut error: \" + error_8);\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.reset = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var reset, error_9;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            reset = util_1.promisify(this.device.reset).bind(this.device);\n            return [4\n            /*yield*/\n            , reset()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_9 = _a.sent();\n            throw new Error(\"reset error: \" + error_9);\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.isochronousTransferIn = function (_endpointNumber, _packetLengths) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('isochronousTransferIn error: method not implemented');\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.isochronousTransferOut = function (_endpointNumber, _data, _packetLengths) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('isochronousTransferOut error: method not implemented');\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.forget = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('forget error: method not implemented');\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.initialize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, _c, _d, error_10;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 5, 6, 7]);\n\n            if (!this.opened) {\n              this.device.open();\n            }\n\n            _a = this;\n            return [4\n            /*yield*/\n            , this.getStringDescriptor(this.device.deviceDescriptor.iManufacturer)];\n\n          case 1:\n            _a.manufacturerName = _e.sent();\n            _b = this;\n            return [4\n            /*yield*/\n            , this.getStringDescriptor(this.device.deviceDescriptor.iProduct)];\n\n          case 2:\n            _b.productName = _e.sent();\n            _c = this;\n            return [4\n            /*yield*/\n            , this.getStringDescriptor(this.device.deviceDescriptor.iSerialNumber)];\n\n          case 3:\n            _c.serialNumber = _e.sent();\n            _d = this;\n            return [4\n            /*yield*/\n            , this.getConfigurations()];\n\n          case 4:\n            _d.configurations = _e.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            error_10 = _e.sent();\n            throw new Error(\"initialize error: \" + error_10);\n\n          case 6:\n            if (this.opened) {\n              this.device.close();\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.decodeVersion = function (version) {\n    var hex = (\"0000\" + version.toString(16)).slice(-4);\n    return {\n      major: parseInt(hex.substr(0, 2), undefined),\n      minor: parseInt(hex.substr(2, 1), undefined),\n      sub: parseInt(hex.substr(3, 1), undefined)\n    };\n  };\n\n  WebUSBDevice.prototype.getStringDescriptor = function (index) {\n    return __awaiter(this, void 0, void 0, function () {\n      var getStringDescriptor, buffer, error_11;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            getStringDescriptor = util_1.promisify(this.device.getStringDescriptor).bind(this.device);\n            return [4\n            /*yield*/\n            , getStringDescriptor(index)];\n\n          case 1:\n            buffer = _a.sent();\n            return [2\n            /*return*/\n            , buffer ? buffer.toString() : ''];\n\n          case 2:\n            error_11 = _a.sent();\n            return [2\n            /*return*/\n            , ''];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.getConfigurations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var configs, _a, _b, config, interfaces, _loop_1, this_1, _c, _d, iface, e_2_1, _e, _f, e_3_1;\n\n      var e_3, _g, e_2, _h, _j;\n\n      var _this = this;\n\n      return __generator(this, function (_k) {\n        switch (_k.label) {\n          case 0:\n            configs = [];\n            _k.label = 1;\n\n          case 1:\n            _k.trys.push([1, 14, 15, 16]);\n\n            _a = __values(this.device.allConfigDescriptors), _b = _a.next();\n            _k.label = 2;\n\n          case 2:\n            if (!!_b.done) return [3\n            /*break*/\n            , 13];\n            config = _b.value;\n            interfaces = [];\n\n            _loop_1 = function (iface) {\n              var alternates, iface_2, iface_2_1, alternate_1, endpoints, _l, _m, endpoint, _o, _p, e_4_1, interfaceNumber, alternate;\n\n              var e_4, _q, e_5, _r, _s;\n\n              return __generator(this, function (_t) {\n                switch (_t.label) {\n                  case 0:\n                    alternates = [];\n                    _t.label = 1;\n\n                  case 1:\n                    _t.trys.push([1, 6, 7, 8]);\n\n                    iface_2 = (e_4 = void 0, __values(iface)), iface_2_1 = iface_2.next();\n                    _t.label = 2;\n\n                  case 2:\n                    if (!!iface_2_1.done) return [3\n                    /*break*/\n                    , 5];\n                    alternate_1 = iface_2_1.value;\n                    endpoints = [];\n\n                    try {\n                      for (_l = (e_5 = void 0, __values(alternate_1.endpoints)), _m = _l.next(); !_m.done; _m = _l.next()) {\n                        endpoint = _m.value;\n                        endpoints.push({\n                          endpointNumber: endpoint.bEndpointAddress & ENDPOINT_NUMBER_MASK,\n                          direction: endpoint.bEndpointAddress & usb.LIBUSB_ENDPOINT_IN ? 'in' : 'out',\n                          type: (endpoint.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_BULK ? 'bulk' : (endpoint.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_INTERRUPT ? 'interrupt' : 'isochronous',\n                          packetSize: endpoint.wMaxPacketSize\n                        });\n                      }\n                    } catch (e_5_1) {\n                      e_5 = {\n                        error: e_5_1\n                      };\n                    } finally {\n                      try {\n                        if (_m && !_m.done && (_r = _l.return)) _r.call(_l);\n                      } finally {\n                        if (e_5) throw e_5.error;\n                      }\n                    }\n\n                    _p = (_o = alternates).push;\n                    _s = {\n                      alternateSetting: alternate_1.bAlternateSetting,\n                      interfaceClass: alternate_1.bInterfaceClass,\n                      interfaceSubclass: alternate_1.bInterfaceSubClass,\n                      interfaceProtocol: alternate_1.bInterfaceProtocol\n                    };\n                    return [4\n                    /*yield*/\n                    , this_1.getStringDescriptor(alternate_1.iInterface)];\n\n                  case 3:\n                    _p.apply(_o, [(_s.interfaceName = _t.sent(), _s.endpoints = endpoints, _s)]);\n\n                    _t.label = 4;\n\n                  case 4:\n                    iface_2_1 = iface_2.next();\n                    return [3\n                    /*break*/\n                    , 2];\n\n                  case 5:\n                    return [3\n                    /*break*/\n                    , 8];\n\n                  case 6:\n                    e_4_1 = _t.sent();\n                    e_4 = {\n                      error: e_4_1\n                    };\n                    return [3\n                    /*break*/\n                    , 8];\n\n                  case 7:\n                    try {\n                      if (iface_2_1 && !iface_2_1.done && (_q = iface_2.return)) _q.call(iface_2);\n                    } finally {\n                      if (e_4) throw e_4.error;\n                    }\n\n                    return [7\n                    /*endfinally*/\n                    ];\n\n                  case 8:\n                    interfaceNumber = iface[0].bInterfaceNumber;\n                    alternate = alternates.find(function (alt) {\n                      return alt.alternateSetting === _this.device.interface(interfaceNumber).altSetting;\n                    });\n\n                    if (alternate) {\n                      interfaces.push({\n                        interfaceNumber: interfaceNumber,\n                        alternate: alternate,\n                        alternates: alternates,\n                        claimed: false\n                      });\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _k.label = 3;\n\n          case 3:\n            _k.trys.push([3, 8, 9, 10]);\n\n            _c = (e_2 = void 0, __values(config.interfaces)), _d = _c.next();\n            _k.label = 4;\n\n          case 4:\n            if (!!_d.done) return [3\n            /*break*/\n            , 7];\n            iface = _d.value;\n            return [5\n            /*yield**/\n            , _loop_1(iface)];\n\n          case 5:\n            _k.sent();\n\n            _k.label = 6;\n\n          case 6:\n            _d = _c.next();\n            return [3\n            /*break*/\n            , 4];\n\n          case 7:\n            return [3\n            /*break*/\n            , 10];\n\n          case 8:\n            e_2_1 = _k.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            try {\n              if (_d && !_d.done && (_h = _c.return)) _h.call(_c);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 10:\n            _f = (_e = configs).push;\n            _j = {\n              configurationValue: config.bConfigurationValue\n            };\n            return [4\n            /*yield*/\n            , this.getStringDescriptor(config.iConfiguration)];\n\n          case 11:\n            _f.apply(_e, [(_j.configurationName = _k.sent(), _j.interfaces = interfaces, _j)]);\n\n            _k.label = 12;\n\n          case 12:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 13:\n            return [3\n            /*break*/\n            , 16];\n\n          case 14:\n            e_3_1 = _k.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3\n            /*break*/\n            , 16];\n\n          case 15:\n            try {\n              if (_b && !_b.done && (_g = _a.return)) _g.call(_a);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [2\n            /*return*/\n            , configs];\n        }\n      });\n    });\n  };\n\n  WebUSBDevice.prototype.getEndpoint = function (address) {\n    var e_6, _a;\n\n    if (!this.device.interfaces) {\n      return undefined;\n    }\n\n    try {\n      for (var _b = __values(this.device.interfaces), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var iface = _c.value;\n        var endpoint = iface.endpoint(address);\n\n        if (endpoint) {\n          return endpoint;\n        }\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    return undefined;\n  };\n\n  WebUSBDevice.prototype.controlTransferParamsToType = function (setup, direction) {\n    var recipient = setup.recipient === 'device' ? usb.LIBUSB_RECIPIENT_DEVICE : setup.recipient === 'interface' ? usb.LIBUSB_RECIPIENT_INTERFACE : setup.recipient === 'endpoint' ? usb.LIBUSB_RECIPIENT_ENDPOINT : usb.LIBUSB_RECIPIENT_OTHER;\n    var requestType = setup.requestType === 'standard' ? usb.LIBUSB_REQUEST_TYPE_STANDARD : setup.requestType === 'class' ? usb.LIBUSB_REQUEST_TYPE_CLASS : usb.LIBUSB_REQUEST_TYPE_VENDOR;\n    return recipient | requestType | direction;\n  };\n\n  WebUSBDevice.prototype._releaseInterface = function (interfaceNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var iface, iface_3, release, error_12;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.opened) {\n              throw new Error('releaseInterface error: invalid state');\n            }\n\n            if (!this.configuration) {\n              throw new Error('releaseInterface error: interface not found');\n            }\n\n            iface = this.configuration.interfaces.find(function (usbInterface) {\n              return usbInterface.interfaceNumber === interfaceNumber;\n            });\n\n            if (!iface) {\n              throw new Error('releaseInterface error: interface not found');\n            }\n\n            if (!iface.claimed) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            iface_3 = this.device.interface(interfaceNumber);\n            release = util_1.promisify(iface_3.release).bind(iface_3);\n            return [4\n            /*yield*/\n            , release()];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_12 = _a.sent();\n            throw new Error(\"releaseInterface error: \" + error_12);\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return WebUSBDevice;\n}();\n\nexports.WebUSBDevice = WebUSBDevice;","map":{"version":3,"mappings":"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","names":["LIBUSB_TRANSFER_TYPE_MASK","ENDPOINT_NUMBER_MASK","CLEAR_FEATURE","ENDPOINT_HALT","device","usbVersion","decodeVersion","deviceDescriptor","bcdUSB","usbVersionMajor","major","usbVersionMinor","minor","usbVersionSubminor","sub","deviceClass","bDeviceClass","deviceSubclass","bDeviceSubClass","deviceProtocol","bDeviceProtocol","vendorId","idVendor","productId","idProduct","deviceVersion","bcdDevice","deviceVersionMajor","deviceVersionMinor","deviceVersionSubminor","WebUSBDevice","instance","initialize","_b","undefined","Object","configDescriptor","currentConfiguration","bConfigurationValue","configurations","find","configurationValue","interfaces","opened","open","error","Error","configuration","_a","_c","iface","_releaseInterface","interfaceNumber","_e","indexOf","alternate","alternates","claimed","close","error_1","config","setConfiguration","util_1","bind","error_2","interface","claim","alternateSetting","iface_1","setAltSetting","error_3","setup","length","type","controlTransferParamsToType","usb","LIBUSB_ENDPOINT_IN","controlTransfer","request","value","index","result","data","DataView","Uint8Array","buffer","status","error_4","errno","LIBUSB_TRANSFER_STALL","LIBUSB_TRANSFER_OVERFLOW","LIBUSB_ENDPOINT_OUT","Buffer","from","alloc","bytesWritten","error_5","direction","endpointNumber","wIndex","LIBUSB_RECIPIENT_ENDPOINT","error_6","endpoint","getEndpoint","transfer","error_7","error_8","reset","error_9","_endpointNumber","_packetLengths","_data","getStringDescriptor","iManufacturer","manufacturerName","iProduct","productName","iSerialNumber","serialNumber","_d","getConfigurations","error_10","version","hex","toString","slice","parseInt","substr","configs","allConfigDescriptors","iface_2","iface_2_1","alternate_1","endpoints","_l","_m","push","bEndpointAddress","bmAttributes","LIBUSB_TRANSFER_TYPE_BULK","LIBUSB_TRANSFER_TYPE_INTERRUPT","packetSize","wMaxPacketSize","_p","bAlternateSetting","interfaceClass","bInterfaceClass","interfaceSubclass","bInterfaceSubClass","interfaceProtocol","bInterfaceProtocol","this_1","iInterface","_s","_t","bInterfaceNumber","_this","altSetting","_f","iConfiguration","_j","_k","address","recipient","LIBUSB_RECIPIENT_DEVICE","LIBUSB_RECIPIENT_INTERFACE","LIBUSB_RECIPIENT_OTHER","requestType","LIBUSB_REQUEST_TYPE_STANDARD","LIBUSB_REQUEST_TYPE_CLASS","LIBUSB_REQUEST_TYPE_VENDOR","iface_3","release","error_12","exports"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\webusb\\webusb-device.ts"],"sourcesContent":["import * as usb from '../usb';\nimport { promisify } from 'util';\nimport { Endpoint, InEndpoint, OutEndpoint } from '../usb/endpoint';\n\nconst LIBUSB_TRANSFER_TYPE_MASK = 0x03;\nconst ENDPOINT_NUMBER_MASK = 0x7f;\nconst CLEAR_FEATURE = 0x01;\nconst ENDPOINT_HALT = 0x00;\n\n/**\n * Wrapper to make a node-usb device look like a webusb device\n */\nexport class WebUSBDevice implements USBDevice {\n    public static async createInstance(device: usb.Device): Promise<WebUSBDevice | undefined> {\n        try {\n            const instance = new WebUSBDevice(device);\n            await instance.initialize();\n            return instance;\n        } catch {\n            return undefined;\n        }\n    }\n\n    public readonly usbVersionMajor: number;\n    public readonly usbVersionMinor: number;\n    public readonly usbVersionSubminor: number;\n    public readonly deviceClass: number;\n    public readonly deviceSubclass: number;\n    public readonly deviceProtocol: number;\n    public readonly vendorId: number;\n    public readonly productId: number;\n    public readonly deviceVersionMajor: number;\n    public readonly deviceVersionMinor: number;\n    public readonly deviceVersionSubminor: number;\n\n    public manufacturerName?: string | undefined;\n    public productName?: string | undefined;\n    public serialNumber?: string | undefined;\n    public configurations: USBConfiguration[] = [];\n\n    private constructor(private device: usb.Device) {\n        const usbVersion = this.decodeVersion(device.deviceDescriptor.bcdUSB);\n        this.usbVersionMajor = usbVersion.major;\n        this.usbVersionMinor = usbVersion.minor;\n        this.usbVersionSubminor = usbVersion.sub;\n\n        this.deviceClass = device.deviceDescriptor.bDeviceClass;\n        this.deviceSubclass = device.deviceDescriptor.bDeviceSubClass;\n        this.deviceProtocol = device.deviceDescriptor.bDeviceProtocol;\n        this.vendorId = device.deviceDescriptor.idVendor;\n        this.productId = device.deviceDescriptor.idProduct;\n\n        const deviceVersion = this.decodeVersion(device.deviceDescriptor.bcdDevice);\n        this.deviceVersionMajor = deviceVersion.major;\n        this.deviceVersionMinor = deviceVersion.minor;\n        this.deviceVersionSubminor = deviceVersion.sub;\n    }\n\n    public get configuration(): USBConfiguration | undefined {\n        if (!this.device.configDescriptor) {\n            return undefined;\n        }\n        const currentConfiguration = this.device.configDescriptor.bConfigurationValue;\n        return this.configurations.find(configuration => configuration.configurationValue === currentConfiguration);\n    }\n\n    public get opened(): boolean {\n        return (!!this.device.interfaces);\n    }\n\n    public async open(): Promise<void> {\n        try {\n            if (this.opened) {\n                return;\n            }\n\n            this.device.open();\n        } catch (error) {\n            throw new Error(`open error: ${error}`);\n        }\n    }\n\n    public async close(): Promise<void> {\n        try {\n            if (!this.opened) {\n                return;\n            }\n\n            try {\n                if (this.configuration) {\n                    for (const iface of this.configuration?.interfaces) {\n                        await this._releaseInterface(iface.interfaceNumber);\n                        // Re-create the USBInterface to set the claimed attribute\n                        this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n                            interfaceNumber: iface.interfaceNumber,\n                            alternate: iface.alternate,\n                            alternates: iface.alternates,\n                            claimed: false\n                        };\n                    }\n                }\n            } catch (_error) {\n                // Ignore\n            }\n\n            this.device.close();\n        } catch (error) {\n            throw new Error(`close error: ${error}`);\n        }\n    }\n\n    public async selectConfiguration(configurationValue: number): Promise<void> {\n        if (!this.opened || !this.device.configDescriptor) {\n            throw new Error('selectConfiguration error: invalid state');\n        }\n\n        if (this.device.configDescriptor.bConfigurationValue === configurationValue) {\n            return;\n        }\n\n        const config = this.configurations.find(configuration => configuration.configurationValue === configurationValue);\n        if (!config) {\n            throw new Error('selectConfiguration error: configuration not found');\n        }\n\n        try {\n            const setConfiguration = promisify(this.device.setConfiguration).bind(this.device);\n            await setConfiguration(configurationValue);\n        } catch (error) {\n            throw new Error(`selectConfiguration error: ${error}`);\n        }\n    }\n\n    public async claimInterface(interfaceNumber: number): Promise<void> {\n        if (!this.opened) {\n            throw new Error('claimInterface error: invalid state');\n        }\n\n        if (!this.configuration) {\n            throw new Error('claimInterface error: interface not found');\n        }\n\n        const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n        if (!iface) {\n            throw new Error('claimInterface error: interface not found');\n        }\n\n        if (iface.claimed) {\n            return;\n        }\n\n        try {\n            this.device.interface(interfaceNumber).claim();\n\n            // Re-create the USBInterface to set the claimed attribute\n            this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n                interfaceNumber,\n                alternate: iface.alternate,\n                alternates: iface.alternates,\n                claimed: true\n            };\n        } catch (error) {\n            throw new Error(`claimInterface error: ${error}`);\n        }\n    }\n\n    public async releaseInterface(interfaceNumber: number): Promise<void> {\n        await this._releaseInterface(interfaceNumber);\n\n        if (this.configuration) {\n            const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n            if (iface) {\n                // Re-create the USBInterface to set the claimed attribute\n                this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n                    interfaceNumber,\n                    alternate: iface.alternate,\n                    alternates: iface.alternates,\n                    claimed: false\n                };\n            }\n        }\n    }\n\n    public async selectAlternateInterface(interfaceNumber: number, alternateSetting: number): Promise<void> {\n        if (!this.opened) {\n            throw new Error('selectAlternateInterface error: invalid state');\n        }\n\n        if (!this.configuration) {\n            throw new Error('selectAlternateInterface error: interface not found');\n        }\n\n        const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n        if (!iface) {\n            throw new Error('selectAlternateInterface error: interface not found');\n        }\n\n        if (!iface.claimed) {\n            throw new Error('selectAlternateInterface error: invalid state');\n        }\n\n        try {\n            const iface = this.device.interface(interfaceNumber);\n            const setAltSetting = promisify(iface.setAltSetting).bind(iface);\n            await setAltSetting(alternateSetting);\n        } catch (error) {\n            throw new Error(`selectAlternateInterface error: ${error}`);\n        }\n    }\n\n    public async controlTransferIn(setup: USBControlTransferParameters, length: number): Promise<USBInTransferResult> {\n        try {\n            const type = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_IN);\n            const controlTransfer = promisify(this.device.controlTransfer).bind(this.device);\n            const result = await controlTransfer(type, setup.request, setup.value, setup.index, length);\n\n            return {\n                data: result ? new DataView(new Uint8Array(result as Buffer).buffer) : undefined,\n                status: 'ok'\n            };\n        } catch (error) {\n            if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n                return {\n                    status: 'stall'\n                };\n            }\n\n            if (error.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {\n                return {\n                    status: 'babble'\n                };\n            }\n\n            throw new Error(`controlTransferIn error: ${error}`);\n        }\n    }\n\n    public async controlTransferOut(setup: USBControlTransferParameters, data?: ArrayBuffer): Promise<USBOutTransferResult> {\n        try {\n            const type = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_OUT);\n            const controlTransfer = promisify(this.device.controlTransfer).bind(this.device);\n            const buffer = data ? Buffer.from(data) : Buffer.alloc(0);\n            const bytesWritten = <number>await controlTransfer(type, setup.request, setup.value, setup.index, buffer);\n\n            return {\n                bytesWritten,\n                status: 'ok'\n            };\n        } catch (error) {\n            if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n                return {\n                    bytesWritten: 0,\n                    status: 'stall'\n                };\n            }\n\n            throw new Error(`controlTransferOut error: ${error}`);\n        }\n    }\n\n    public async clearHalt(direction: USBDirection, endpointNumber: number): Promise<void> {\n        try {\n            const wIndex = endpointNumber | (direction === 'in' ? usb.LIBUSB_ENDPOINT_IN : usb.LIBUSB_ENDPOINT_OUT);\n            const controlTransfer = promisify(this.device.controlTransfer).bind(this.device);\n            await controlTransfer(usb.LIBUSB_RECIPIENT_ENDPOINT, CLEAR_FEATURE, ENDPOINT_HALT, wIndex, 0);\n        } catch (error) {\n            throw new Error(`clearHalt error: ${error}`);\n        }\n    }\n\n    public async transferIn(endpointNumber: number, length: number): Promise<USBInTransferResult> {\n        try {\n            const endpoint = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_IN) as InEndpoint;\n            const transfer = promisify(endpoint.transfer).bind(endpoint);\n            const result = await transfer(length);\n\n            return {\n                data: result ? new DataView(new Uint8Array(result).buffer) : undefined,\n                status: 'ok'\n            };\n        } catch (error) {\n            if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n                return {\n                    status: 'stall'\n                };\n            }\n\n            if (error.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {\n                return {\n                    status: 'babble'\n                };\n            }\n\n            throw new Error(`transferIn error: ${error}`);\n        }\n    }\n\n    public async transferOut(endpointNumber: number, data: ArrayBuffer): Promise<USBOutTransferResult> {\n        try {\n            const endpoint = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_OUT) as OutEndpoint;\n            const transfer = promisify(endpoint.transfer).bind(endpoint);\n            const buffer = Buffer.from(data);\n            const bytesWritten = await transfer(buffer);\n\n            return {\n                bytesWritten,\n                status: 'ok'\n            };\n        } catch (error) {\n            if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n                return {\n                    bytesWritten: 0,\n                    status: 'stall'\n                };\n            }\n\n            throw new Error(`transferOut error: ${error}`);\n        }\n    }\n\n    public async reset(): Promise<void> {\n        try {\n            const reset = promisify(this.device.reset).bind(this.device);\n            await reset();\n        } catch (error) {\n            throw new Error(`reset error: ${error}`);\n        }\n    }\n\n    public async isochronousTransferIn(_endpointNumber: number, _packetLengths: number[]): Promise<USBIsochronousInTransferResult> {\n        throw new Error('isochronousTransferIn error: method not implemented');\n    }\n\n    public async isochronousTransferOut(_endpointNumber: number, _data: BufferSource, _packetLengths: number[]): Promise<USBIsochronousOutTransferResult> {\n        throw new Error('isochronousTransferOut error: method not implemented');\n    }\n\n    public async forget(): Promise<void> {\n        throw new Error('forget error: method not implemented');\n    }\n\n    private async initialize(): Promise<void> {\n        try {\n            if (!this.opened) {\n                this.device.open();\n            }\n\n            this.manufacturerName = await this.getStringDescriptor(this.device.deviceDescriptor.iManufacturer);\n            this.productName = await this.getStringDescriptor(this.device.deviceDescriptor.iProduct);\n            this.serialNumber = await this.getStringDescriptor(this.device.deviceDescriptor.iSerialNumber);\n            this.configurations = await this.getConfigurations();\n        } catch (error) {\n            throw new Error(`initialize error: ${error}`);\n        } finally {\n            if (this.opened) {\n                this.device.close();\n            }\n        }\n    }\n\n    private decodeVersion(version: number): { [key: string]: number } {\n        const hex = `0000${version.toString(16)}`.slice(-4);\n        return {\n            major: parseInt(hex.substr(0, 2), undefined),\n            minor: parseInt(hex.substr(2, 1), undefined),\n            sub: parseInt(hex.substr(3, 1), undefined),\n        };\n    }\n\n    private async getStringDescriptor(index: number): Promise<string> {\n        try {\n            const getStringDescriptor = promisify(this.device.getStringDescriptor).bind(this.device);\n            const buffer = await getStringDescriptor(index);\n            return buffer ? buffer.toString() : '';\n        } catch (error) {\n            return '';\n        }\n    }\n\n    private async getConfigurations(): Promise<USBConfiguration[]> {\n        const configs: USBConfiguration[] = [];\n\n        for (const config of this.device.allConfigDescriptors) {\n            const interfaces: USBInterface[] = [];\n\n            for (const iface of config.interfaces) {\n                const alternates: USBAlternateInterface[] = [];\n\n                for (const alternate of iface) {\n                    const endpoints: USBEndpoint[] = [];\n\n                    for (const endpoint of alternate.endpoints) {\n                        endpoints.push({\n                            endpointNumber: endpoint.bEndpointAddress & ENDPOINT_NUMBER_MASK,\n                            direction: endpoint.bEndpointAddress & usb.LIBUSB_ENDPOINT_IN ? 'in' : 'out',\n                            type: (endpoint.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_BULK ? 'bulk'\n                                : (endpoint.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_INTERRUPT ? 'interrupt'\n                                    : 'isochronous',\n                            packetSize: endpoint.wMaxPacketSize\n                        });\n                    }\n\n                    alternates.push({\n                        alternateSetting: alternate.bAlternateSetting,\n                        interfaceClass: alternate.bInterfaceClass,\n                        interfaceSubclass: alternate.bInterfaceSubClass,\n                        interfaceProtocol: alternate.bInterfaceProtocol,\n                        interfaceName: await this.getStringDescriptor(alternate.iInterface),\n                        endpoints\n                    });\n                }\n\n                const interfaceNumber = iface[0].bInterfaceNumber;\n                const alternate = alternates.find(alt => alt.alternateSetting === this.device.interface(interfaceNumber).altSetting);\n\n                if (alternate) {\n                    interfaces.push({\n                        interfaceNumber,\n                        alternate,\n                        alternates,\n                        claimed: false\n                    });\n                }\n            }\n\n            configs.push({\n                configurationValue: config.bConfigurationValue,\n                configurationName: await this.getStringDescriptor(config.iConfiguration),\n                interfaces\n            });\n        }\n\n        return configs;\n    }\n\n    private getEndpoint(address: number): Endpoint | undefined {\n        if (!this.device.interfaces) {\n            return undefined;\n        }\n\n        for (const iface of this.device.interfaces) {\n            const endpoint = iface.endpoint(address);\n            if (endpoint) {\n                return endpoint;\n            }\n        }\n\n        return undefined;\n    }\n\n    private controlTransferParamsToType(setup: USBControlTransferParameters, direction: number): number {\n        const recipient = setup.recipient === 'device' ? usb.LIBUSB_RECIPIENT_DEVICE\n            : setup.recipient === 'interface' ? usb.LIBUSB_RECIPIENT_INTERFACE\n                : setup.recipient === 'endpoint' ? usb.LIBUSB_RECIPIENT_ENDPOINT\n                    : usb.LIBUSB_RECIPIENT_OTHER;\n\n        const requestType = setup.requestType === 'standard' ? usb.LIBUSB_REQUEST_TYPE_STANDARD\n            : setup.requestType === 'class' ? usb.LIBUSB_REQUEST_TYPE_CLASS\n                : usb.LIBUSB_REQUEST_TYPE_VENDOR;\n\n        return recipient | requestType | direction;\n    }\n\n    private async _releaseInterface(interfaceNumber: number): Promise<void> {\n        if (!this.opened) {\n            throw new Error('releaseInterface error: invalid state');\n        }\n\n        if (!this.configuration) {\n            throw new Error('releaseInterface error: interface not found');\n        }\n\n        const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n        if (!iface) {\n            throw new Error('releaseInterface error: interface not found');\n        }\n\n        if (!iface.claimed) {\n            return;\n        }\n\n        try {\n            const iface = this.device.interface(interfaceNumber);\n            const release = promisify(iface.release).bind(iface);\n            await release();\n        } catch (error) {\n            throw new Error(`releaseInterface error: ${error}`);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}