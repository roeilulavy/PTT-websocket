{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebUSBDevice = exports.WebUSB = exports.webusb = exports.getWebUsb = exports.findBySerialNumber = exports.findByIds = exports.getDeviceList = exports.useUsbDkBackend = exports.usb = void 0;\n\nvar util_1 = require(\"util\");\n\nvar webusb_1 = require(\"./webusb\");\n\nObject.defineProperty(exports, \"WebUSB\", {\n  enumerable: true,\n  get: function () {\n    return webusb_1.WebUSB;\n  }\n});\nObject.defineProperty(exports, \"getWebUsb\", {\n  enumerable: true,\n  get: function () {\n    return webusb_1.getWebUsb;\n  }\n});\n\nvar webusb_device_1 = require(\"./webusb/webusb-device\");\n\nObject.defineProperty(exports, \"WebUSBDevice\", {\n  enumerable: true,\n  get: function () {\n    return webusb_device_1.WebUSBDevice;\n  }\n});\n\nvar usb = require(\"./usb\");\n\nexports.usb = usb;\nvar webusb = new webusb_1.WebUSB();\nexports.webusb = webusb;\nvar getDeviceList = usb.getDeviceList;\nexports.getDeviceList = getDeviceList;\nvar useUsbDkBackend = usb.useUsbDkBackend;\nexports.useUsbDkBackend = useUsbDkBackend;\n/**\n * Convenience method to get the first device with the specified VID and PID, or `undefined` if no such device is present.\n * @param vid\n * @param pid\n */\n\nvar findByIds = function (vid, pid) {\n  var devices = usb.getDeviceList();\n  return devices.find(function (item) {\n    return item.deviceDescriptor.idVendor === vid && item.deviceDescriptor.idProduct === pid;\n  });\n};\n\nexports.findByIds = findByIds;\n/**\n * Convenience method to get the device with the specified serial number, or `undefined` if no such device is present.\n * @param serialNumber\n */\n\nvar findBySerialNumber = function (serialNumber) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var devices, opened, devices_1, devices_1_1, device, getStringDescriptor, buffer, _a, e_1_1;\n\n    var e_1, _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          devices = usb.getDeviceList();\n\n          opened = function (device) {\n            return !!device.interfaces;\n          };\n\n          _c.label = 1;\n\n        case 1:\n          _c.trys.push([1, 9, 10, 11]);\n\n          devices_1 = __values(devices), devices_1_1 = devices_1.next();\n          _c.label = 2;\n\n        case 2:\n          if (!!devices_1_1.done) return [3\n          /*break*/\n          , 8];\n          device = devices_1_1.value;\n          _c.label = 3;\n\n        case 3:\n          _c.trys.push([3, 5, 6, 7]);\n\n          if (!opened(device)) {\n            device.open();\n          }\n\n          getStringDescriptor = util_1.promisify(device.getStringDescriptor).bind(device);\n          return [4\n          /*yield*/\n          , getStringDescriptor(device.deviceDescriptor.iSerialNumber)];\n\n        case 4:\n          buffer = _c.sent();\n\n          if (buffer && buffer.toString() === serialNumber) {\n            return [2\n            /*return*/\n            , device];\n          }\n\n          return [3\n          /*break*/\n          , 7];\n\n        case 5:\n          _a = _c.sent();\n          return [3\n          /*break*/\n          , 7];\n\n        case 6:\n          try {\n            if (opened(device)) {\n              device.close();\n            }\n          } catch (_d) {// Ignore any errors, device may be a system device or inaccessible\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 7:\n          devices_1_1 = devices_1.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 8:\n          return [3\n          /*break*/\n          , 11];\n\n        case 9:\n          e_1_1 = _c.sent();\n          e_1 = {\n            error: e_1_1\n          };\n          return [3\n          /*break*/\n          , 11];\n\n        case 10:\n          try {\n            if (devices_1_1 && !devices_1_1.done && (_b = devices_1.return)) _b.call(devices_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 11:\n          return [2\n          /*return*/\n          , undefined];\n      }\n    });\n  });\n};\n\nexports.findBySerialNumber = findBySerialNumber;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAqEIA;EAAAC;EAAAC;IAAA,OArEKC,eAqEL;EArEW;AAqEX;AANAH;EAAAC;EAAAC;IAAA,OA/DaC,kBA+Db;EA/DsB;AA+DtB;;AA9DJ;;AAuEIH;EAAAC;EAAAC;IAAA,OAvEKE,4BAuEL;EAvEiB;AAuEjB;;AAtEJ;;AAsDIC;AApDJ,IAAMC,MAAM,GAAG,IAAIH,eAAJ,EAAf;AA8DIE;AA7DJ,IAAME,aAAa,GAAGC,GAAG,CAACD,aAA1B;AAuDIF;AAtDJ,IAAMI,eAAe,GAAGD,GAAG,CAACC,eAA5B;AAqDIJ;AAnDJ;;;;;;AAKA,IAAMK,SAAS,GAAG,UAACC,GAAD,EAAcC,GAAd,EAAyB;EACvC,IAAMC,OAAO,GAAGL,GAAG,CAACD,aAAJ,EAAhB;EACA,OAAOM,OAAO,CAACC,IAAR,CAAa,gBAAI;IAAI,WAAI,CAACC,gBAAL,CAAsBC,QAAtB,KAAmCL,GAAnC,IAA0CM,IAAI,CAACF,gBAAL,CAAsBG,SAAtB,KAAoCN,GAA9E;EAAiF,CAAtG,CAAP;AACH,CAHD;;AAgDIP;AA3CJ;;;;;AAIA,IAAMc,kBAAkB,GAAG,UAAOC,YAAP,EAA2B;EAAA;;;;;;;;UAC5CP,OAAO,GAAGL,GAAG,CAACD,aAAJ,EAAV;;UACAc,MAAM,GAAG,UAACC,MAAD,EAAmB;YAAc,QAAC,CAACA,MAAM,CAACC,UAAT;UAAmB,CAA7D;;;;;;;UAEeC,+BAAOC,8BAAP;;;;;;;UAAVH,MAAM,oBAAN;;;;;;UAEH,IAAI,CAACD,MAAM,CAACC,MAAD,CAAX,EAAqB;YACjBA,MAAM,CAACI,IAAP;UACH;;UAEKC,mBAAmB,GAAGC,iBAAUN,MAAM,CAACK,mBAAjB,EAAsCE,IAAtC,CAA2CP,MAA3C,CAAtB;UACS;UAAA;UAAA,EAAMK,mBAAmB,CAACL,MAAM,CAACP,gBAAP,CAAwBe,aAAzB,CAAzB;;;UAATC,MAAM,GAAGC,SAAT;;UAEN,IAAID,MAAM,IAAIA,MAAM,CAACE,QAAP,OAAsBb,YAApC,EAAkD;YAC9C;YAAA;YAAA,EAAOE,MAAP;UACH;;;;;;;;;;;;;UAID,IAAI;YACA,IAAID,MAAM,CAACC,MAAD,CAAV,EAAoB;cAChBA,MAAM,CAACY,KAAP;YACH;UACJ,CAJD,CAIE,WAAM,CACJ;UACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAIT;UAAA;UAAA,EAAOC,SAAP;;;GA7BkD;AA8BrD,CA9BD;;AAwCI9B","names":["Object","enumerable","get","webusb_1","webusb_device_1","exports","webusb","getDeviceList","usb","useUsbDkBackend","findByIds","vid","pid","devices","find","deviceDescriptor","idVendor","item","idProduct","findBySerialNumber","serialNumber","opened","device","interfaces","devices_1","devices_1_1","open","getStringDescriptor","util_1","bind","iSerialNumber","buffer","_c","toString","close","undefined"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\index.ts"],"sourcesContent":["import { promisify } from 'util';\nimport { WebUSB, getWebUsb } from './webusb';\nimport { WebUSBDevice } from './webusb/webusb-device';\nimport * as usb from './usb';\n\nconst webusb = new WebUSB();\nconst getDeviceList = usb.getDeviceList;\nconst useUsbDkBackend = usb.useUsbDkBackend;\n\n/**\n * Convenience method to get the first device with the specified VID and PID, or `undefined` if no such device is present.\n * @param vid\n * @param pid\n */\nconst findByIds = (vid: number, pid: number): usb.Device | undefined => {\n    const devices = usb.getDeviceList();\n    return devices.find(item => item.deviceDescriptor.idVendor === vid && item.deviceDescriptor.idProduct === pid);\n};\n\n/**\n * Convenience method to get the device with the specified serial number, or `undefined` if no such device is present.\n * @param serialNumber\n */\nconst findBySerialNumber = async (serialNumber: string): Promise<usb.Device | undefined> => {\n    const devices = usb.getDeviceList();\n    const opened = (device: usb.Device): boolean => !!device.interfaces;\n\n    for (const device of devices) {\n        try {\n            if (!opened(device)) {\n                device.open();\n            }\n\n            const getStringDescriptor = promisify(device.getStringDescriptor).bind(device);\n            const buffer = await getStringDescriptor(device.deviceDescriptor.iSerialNumber);\n\n            if (buffer && buffer.toString() === serialNumber) {\n                return device;\n            }\n        } catch {\n            // Ignore any errors, device may be a system device or inaccessible\n        } finally {\n            try {\n                if (opened(device)) {\n                    device.close();\n                }\n            } catch {\n                // Ignore any errors, device may be a system device or inaccessible\n            }\n        }\n    }\n\n    return undefined;\n};\n\nexport {\n    // Core usb object for quick access\n    usb,\n\n    // Convenience methods\n    useUsbDkBackend,\n    getDeviceList,\n    findByIds,\n    findBySerialNumber,\n    getWebUsb,\n\n    // Default WebUSB object (mimics navigator.usb)\n    webusb,\n\n    // WebUSB class for creating custom webusb instances\n    WebUSB,\n\n    // WebUSB Device class for turning a legacy usb.Device into a webusb device\n    WebUSBDevice\n};\n"]},"metadata":{},"sourceType":"script"}