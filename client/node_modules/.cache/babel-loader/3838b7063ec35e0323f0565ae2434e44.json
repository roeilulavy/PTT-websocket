{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OutEndpoint = exports.InEndpoint = exports.Endpoint = void 0;\n\nvar events_1 = require(\"events\");\n\nvar bindings_1 = require(\"./bindings\");\n\nvar isBuffer = function (obj) {\n  return obj && obj instanceof Uint8Array;\n};\n/** Common base for InEndpoint and OutEndpoint. */\n\n\nvar Endpoint =\n/** @class */\nfunction (_super) {\n  __extends(Endpoint, _super);\n\n  function Endpoint(device, descriptor) {\n    var _this = _super.call(this) || this;\n\n    _this.device = device;\n    /** Sets the timeout in milliseconds for transfers on this endpoint. The default, `0`, is infinite timeout. */\n\n    _this.timeout = 0;\n    _this.descriptor = descriptor;\n    _this.address = descriptor.bEndpointAddress;\n    _this.transferType = descriptor.bmAttributes & 0x03;\n    return _this;\n  }\n  /** Clear the halt/stall condition for this endpoint. */\n\n\n  Endpoint.prototype.clearHalt = function (callback) {\n    return this.device.__clearHalt(this.address, callback);\n  };\n  /**\n   * Create a new `Transfer` object for this endpoint.\n   *\n   * The passed callback will be called when the transfer is submitted and finishes. Its arguments are the error (if any), the submitted buffer, and the amount of data actually written (for\n   * OUT transfers) or read (for IN transfers).\n   *\n   * @param timeout Timeout for the transfer (0 means unlimited).\n   * @param callback Transfer completion callback.\n   */\n\n\n  Endpoint.prototype.makeTransfer = function (timeout, callback) {\n    return new bindings_1.Transfer(this.device, this.address, this.transferType, timeout, callback);\n  };\n\n  return Endpoint;\n}(events_1.EventEmitter);\n\nexports.Endpoint = Endpoint;\n/** Endpoints in the IN direction (device->PC) have this type. */\n\nvar InEndpoint =\n/** @class */\nfunction (_super) {\n  __extends(InEndpoint, _super);\n\n  function InEndpoint(device, descriptor) {\n    var _this = _super.call(this, device, descriptor) || this;\n    /** Endpoint direction. */\n\n\n    _this.direction = 'in';\n    _this.pollTransfers = [];\n    _this.pollTransferSize = 0;\n    _this.pollPending = 0;\n    _this.pollActive = false;\n    return _this;\n  }\n  /**\n   * Perform a transfer to read data from the endpoint.\n   *\n   * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback with all data once all packets are complete.\n   *\n   * `this` in the callback is the InEndpoint object.\n   *\n   * The device must be open to use this method.\n   * @param length\n   * @param callback\n   */\n\n\n  InEndpoint.prototype.transfer = function (length, callback) {\n    var _this = this;\n\n    var buffer = Buffer.alloc(length);\n\n    var cb = function (error, _buffer, actualLength) {\n      callback.call(_this, error, buffer.slice(0, actualLength));\n    };\n\n    try {\n      this.makeTransfer(this.timeout, cb).submit(buffer);\n    } catch (e) {\n      process.nextTick(function () {\n        return callback.call(_this, e);\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Start polling the endpoint.\n   *\n   * The library will keep `nTransfers` transfers of size `transferSize` pending in the kernel at all times to ensure continuous data flow.\n   * This is handled by the libusb event thread, so it continues even if the Node v8 thread is busy. The `data` and `error` events are emitted as transfers complete.\n   *\n   * The device must be open to use this method.\n   * @param nTransfers\n   * @param transferSize\n   */\n\n\n  InEndpoint.prototype.startPoll = function (nTransfers, transferSize, _callback) {\n    var _this = this;\n\n    var transferDone = function (error, transfer, buffer, actualLength) {\n      if (!error) {\n        _this.emit('data', buffer.slice(0, actualLength));\n      } else if (error.errno != bindings_1.LIBUSB_TRANSFER_CANCELLED) {\n        _this.emit('error', error);\n\n        _this.stopPoll();\n      }\n\n      if (_this.pollActive) {\n        startTransfer(transfer);\n      } else {\n        _this.pollPending--;\n\n        if (_this.pollPending === 0) {\n          _this.pollTransfers = [];\n          _this.pollActive = false;\n\n          _this.emit('end');\n        }\n      }\n    };\n\n    var startTransfer = function (transfer) {\n      try {\n        transfer.submit(Buffer.alloc(_this.pollTransferSize), function (error, buffer, actualLength) {\n          transferDone(error, transfer, buffer, actualLength);\n        });\n      } catch (e) {\n        _this.emit('error', e);\n\n        _this.stopPoll();\n      }\n    };\n\n    this.pollTransfers = this.startPollTransfers(nTransfers, transferSize, function (error, buffer, actualLength) {\n      transferDone(error, this, buffer, actualLength);\n    });\n    this.pollTransfers.forEach(startTransfer);\n    this.pollPending = this.pollTransfers.length;\n    return this.pollTransfers;\n  };\n\n  InEndpoint.prototype.startPollTransfers = function (nTransfers, transferSize, callback) {\n    if (nTransfers === void 0) {\n      nTransfers = 3;\n    }\n\n    if (transferSize === void 0) {\n      transferSize = this.descriptor.wMaxPacketSize;\n    }\n\n    if (this.pollActive) {\n      throw new Error('Polling already active');\n    }\n\n    this.pollTransferSize = transferSize;\n    this.pollActive = true;\n    this.pollPending = 0;\n    var transfers = [];\n\n    for (var i = 0; i < nTransfers; i++) {\n      var transfer = this.makeTransfer(0, callback);\n      transfers[i] = transfer;\n    }\n\n    return transfers;\n  };\n  /**\n   * Stop polling.\n   *\n   * Further data may still be received. The `end` event is emitted and the callback is called once all transfers have completed or canceled.\n   *\n   * The device must be open to use this method.\n   * @param callback\n   */\n\n\n  InEndpoint.prototype.stopPoll = function (callback) {\n    if (!this.pollActive) {\n      throw new Error('Polling is not active.');\n    }\n\n    for (var i = 0; i < this.pollTransfers.length; i++) {\n      try {\n        this.pollTransfers[i].cancel();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n\n    this.pollActive = false;\n    if (callback) this.once('end', callback);\n  };\n\n  return InEndpoint;\n}(Endpoint);\n\nexports.InEndpoint = InEndpoint;\n/** Endpoints in the OUT direction (PC->device) have this type. */\n\nvar OutEndpoint =\n/** @class */\nfunction (_super) {\n  __extends(OutEndpoint, _super);\n\n  function OutEndpoint() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** Endpoint direction. */\n\n\n    _this.direction = 'out';\n    return _this;\n  }\n  /**\n   * Perform a transfer to write `data` to the endpoint.\n   *\n   * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback once all packets are complete.\n   *\n   * `this` in the callback is the OutEndpoint object.\n   *\n   * The device must be open to use this method.\n   * @param buffer\n   * @param callback\n   */\n\n\n  OutEndpoint.prototype.transfer = function (buffer, callback) {\n    var _this = this;\n\n    if (!buffer) {\n      buffer = Buffer.alloc(0);\n    } else if (!isBuffer(buffer)) {\n      buffer = Buffer.from(buffer);\n    }\n\n    var cb = function (error, _buffer, actual) {\n      if (callback) {\n        callback.call(_this, error, actual || 0);\n      }\n    };\n\n    try {\n      this.makeTransfer(this.timeout, cb).submit(buffer);\n    } catch (e) {\n      process.nextTick(function () {\n        return cb(e);\n      });\n    }\n\n    return this;\n  };\n\n  OutEndpoint.prototype.transferWithZLP = function (buffer, callback) {\n    if (buffer.length % this.descriptor.wMaxPacketSize === 0) {\n      this.transfer(buffer);\n      this.transfer(Buffer.alloc(0), callback);\n    } else {\n      this.transfer(buffer, callback);\n    }\n  };\n\n  return OutEndpoint;\n}(Endpoint);\n\nexports.OutEndpoint = OutEndpoint;","map":{"version":3,"mappings":"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","names":["isBuffer","obj","Uint8Array","__extends","device","descriptor","_super","_this","address","bEndpointAddress","transferType","bmAttributes","Endpoint","callback","__clearHalt","timeout","bindings_1","events_1","exports","InEndpoint","length","buffer","Buffer","alloc","cb","error","_buffer","actualLength","call","slice","makeTransfer","submit","e","process","nextTick","nTransfers","transferSize","_callback","transferDone","transfer","emit","errno","stopPoll","pollActive","startTransfer","pollPending","pollTransfers","pollTransferSize","startPollTransfers","forEach","wMaxPacketSize","Error","transfers","i","cancel","once","OutEndpoint","from","actual"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\usb\\endpoint.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport { LibUSBException, LIBUSB_TRANSFER_CANCELLED, Transfer, Device } from './bindings';\nimport { EndpointDescriptor } from './descriptors';\n\nconst isBuffer = (obj: ArrayBuffer | Buffer): obj is Uint8Array => obj && obj instanceof Uint8Array;\n\n/** Common base for InEndpoint and OutEndpoint. */\nexport abstract class Endpoint extends EventEmitter {\n    public address: number;\n\n    /** Endpoint direction: `\"in\"` or `\"out\"`. */\n    public abstract direction: 'in' | 'out';\n\n    /** Endpoint type: `usb.LIBUSB_TRANSFER_TYPE_BULK`, `usb.LIBUSB_TRANSFER_TYPE_INTERRUPT`, or `usb.LIBUSB_TRANSFER_TYPE_ISOCHRONOUS`. */\n    public transferType: number;\n\n    /** Sets the timeout in milliseconds for transfers on this endpoint. The default, `0`, is infinite timeout. */\n    public timeout = 0;\n\n    /** Object with fields from the endpoint descriptor -- see libusb documentation or USB spec. */\n    public descriptor: EndpointDescriptor;\n\n    constructor(protected device: Device, descriptor: EndpointDescriptor) {\n        super();\n        this.descriptor = descriptor;\n        this.address = descriptor.bEndpointAddress;\n        this.transferType = descriptor.bmAttributes & 0x03;\n    }\n\n    /** Clear the halt/stall condition for this endpoint. */\n    public clearHalt(callback: (error: LibUSBException | undefined) => void): void {\n        return this.device.__clearHalt(this.address, callback);\n    }\n\n    /**\n     * Create a new `Transfer` object for this endpoint.\n     *\n     * The passed callback will be called when the transfer is submitted and finishes. Its arguments are the error (if any), the submitted buffer, and the amount of data actually written (for\n     * OUT transfers) or read (for IN transfers).\n     *\n     * @param timeout Timeout for the transfer (0 means unlimited).\n     * @param callback Transfer completion callback.\n     */\n    public makeTransfer(timeout: number, callback: (error: LibUSBException | undefined, buffer: Buffer, actualLength: number) => void): Transfer {\n        return new Transfer(this.device, this.address, this.transferType, timeout, callback);\n    }\n}\n\n/** Endpoints in the IN direction (device->PC) have this type. */\nexport class InEndpoint extends Endpoint {\n\n    /** Endpoint direction. */\n    public direction: 'in' | 'out' = 'in';\n\n    protected pollTransfers: Transfer[] = [];\n    protected pollTransferSize = 0;\n    protected pollPending = 0;\n    public pollActive = false;\n\n    constructor(device: Device, descriptor: EndpointDescriptor) {\n        super(device, descriptor);\n    }\n\n    /**\n     * Perform a transfer to read data from the endpoint.\n     *\n     * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback with all data once all packets are complete.\n     *\n     * `this` in the callback is the InEndpoint object.\n     *\n     * The device must be open to use this method.\n     * @param length\n     * @param callback\n     */\n    public transfer(length: number, callback: (error: LibUSBException | undefined, data?: Buffer) => void): InEndpoint {\n        const buffer = Buffer.alloc(length);\n\n        const cb = (error: LibUSBException | undefined, _buffer?: Buffer, actualLength?: number) => {\n            callback.call(this, error, buffer.slice(0, actualLength));\n        };\n\n        try {\n            this.makeTransfer(this.timeout, cb).submit(buffer);\n        } catch (e) {\n            process.nextTick(() => callback.call(this, e));\n        }\n        return this;\n    }\n\n    /**\n     * Start polling the endpoint.\n     *\n     * The library will keep `nTransfers` transfers of size `transferSize` pending in the kernel at all times to ensure continuous data flow.\n     * This is handled by the libusb event thread, so it continues even if the Node v8 thread is busy. The `data` and `error` events are emitted as transfers complete.\n     *\n     * The device must be open to use this method.\n     * @param nTransfers\n     * @param transferSize\n     */\n    public startPoll(nTransfers?: number, transferSize?: number, _callback?: (error: LibUSBException | undefined, buffer: Buffer, actualLength: number) => void): Transfer[] {\n        const transferDone = (error: LibUSBException | undefined, transfer: Transfer, buffer: Buffer, actualLength: number) => {\n            if (!error) {\n                this.emit('data', buffer.slice(0, actualLength));\n            } else if (error.errno != LIBUSB_TRANSFER_CANCELLED) {\n                this.emit('error', error);\n                this.stopPoll();\n            }\n\n            if (this.pollActive) {\n                startTransfer(transfer);\n            } else {\n                this.pollPending--;\n\n                if (this.pollPending === 0) {\n                    this.pollTransfers = [];\n                    this.pollActive = false;\n                    this.emit('end');\n                }\n            }\n        };\n\n        const startTransfer = (transfer: Transfer) => {\n            try {\n                transfer.submit(Buffer.alloc(this.pollTransferSize), (error, buffer, actualLength) => {\n                    transferDone(error, transfer, buffer, actualLength);\n                });\n            } catch (e) {\n                this.emit('error', e);\n                this.stopPoll();\n            }\n        };\n\n        this.pollTransfers = this.startPollTransfers(nTransfers, transferSize, function (this: Transfer, error, buffer, actualLength) {\n            transferDone(error, this, buffer, actualLength);\n        });\n        this.pollTransfers.forEach(startTransfer);\n        this.pollPending = this.pollTransfers.length;\n        return this.pollTransfers;\n    }\n\n    protected startPollTransfers(nTransfers = 3, transferSize = this.descriptor.wMaxPacketSize, callback: (error: LibUSBException | undefined, buffer: Buffer, actualLength: number) => void): Transfer[] {\n        if (this.pollActive) {\n            throw new Error('Polling already active');\n        }\n\n        this.pollTransferSize = transferSize;\n        this.pollActive = true;\n        this.pollPending = 0;\n\n        const transfers: Transfer[] = [];\n        for (let i = 0; i < nTransfers; i++) {\n            const transfer = this.makeTransfer(0, callback);\n            transfers[i] = transfer;\n        }\n        return transfers;\n    }\n\n    /**\n     * Stop polling.\n     *\n     * Further data may still be received. The `end` event is emitted and the callback is called once all transfers have completed or canceled.\n     *\n     * The device must be open to use this method.\n     * @param callback\n     */\n    public stopPoll(callback?: () => void): void {\n        if (!this.pollActive) {\n            throw new Error('Polling is not active.');\n        }\n        for (let i = 0; i < this.pollTransfers.length; i++) {\n            try {\n                this.pollTransfers[i].cancel();\n            } catch (error) {\n                this.emit('error', error);\n            }\n        }\n        this.pollActive = false;\n        if (callback) this.once('end', callback);\n    }\n}\n\n/** Endpoints in the OUT direction (PC->device) have this type. */\nexport class OutEndpoint extends Endpoint {\n\n    /** Endpoint direction. */\n    public direction: 'in' | 'out' = 'out';\n\n    /**\n     * Perform a transfer to write `data` to the endpoint.\n     *\n     * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback once all packets are complete.\n     *\n     * `this` in the callback is the OutEndpoint object.\n     *\n     * The device must be open to use this method.\n     * @param buffer\n     * @param callback\n     */\n    public transfer(buffer: Buffer, callback?: (error: LibUSBException | undefined, actual: number) => void): OutEndpoint {\n        if (!buffer) {\n            buffer = Buffer.alloc(0);\n        } else if (!isBuffer(buffer)) {\n            buffer = Buffer.from(buffer);\n        }\n\n        const cb = (error: LibUSBException | undefined, _buffer?: Buffer, actual?: number) => {\n            if (callback) {\n                callback.call(this, error, actual || 0);\n            }\n        };\n\n        try {\n            this.makeTransfer(this.timeout, cb).submit(buffer);\n        } catch (e) {\n            process.nextTick(() => cb(e));\n        }\n\n        return this;\n    }\n\n    public transferWithZLP(buffer: Buffer, callback: (error: LibUSBException | undefined) => void): void {\n        if (buffer.length % this.descriptor.wMaxPacketSize === 0) {\n            this.transfer(buffer);\n            this.transfer(Buffer.alloc(0), callback);\n        } else {\n            this.transfer(buffer, callback);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}