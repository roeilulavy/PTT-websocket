{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interface = void 0;\n\nvar bindings_1 = require(\"./bindings\");\n\nvar endpoint_1 = require(\"./endpoint\");\n\nvar Interface =\n/** @class */\nfunction () {\n  function Interface(device, id) {\n    this.device = device;\n    this.id = id;\n    /** Integer alternate setting number. */\n\n    this.altSetting = 0;\n    this.refresh();\n  }\n\n  Interface.prototype.refresh = function () {\n    if (!this.device.configDescriptor) {\n      return;\n    }\n\n    this.descriptor = this.device.configDescriptor.interfaces[this.id][this.altSetting];\n    this.interfaceNumber = this.descriptor.bInterfaceNumber;\n    this.endpoints = [];\n    var len = this.descriptor.endpoints.length;\n\n    for (var i = 0; i < len; i++) {\n      var desc = this.descriptor.endpoints[i];\n      var c = desc.bEndpointAddress & bindings_1.LIBUSB_ENDPOINT_IN ? endpoint_1.InEndpoint : endpoint_1.OutEndpoint;\n      this.endpoints[i] = new c(this.device, desc);\n    }\n  };\n  /**\n   * Claims the interface. This method must be called before using any endpoints of this interface.\n   *\n   * The device must be open to use this method.\n   */\n\n\n  Interface.prototype.claim = function () {\n    this.device.__claimInterface(this.id);\n  };\n\n  Interface.prototype.release = function (closeEndpointsOrCallback, callback) {\n    var _this = this;\n\n    var closeEndpoints = false;\n\n    if (typeof closeEndpointsOrCallback === 'boolean') {\n      closeEndpoints = closeEndpointsOrCallback;\n    } else {\n      callback = closeEndpointsOrCallback;\n    }\n\n    var next = function () {\n      _this.device.__releaseInterface(_this.id, function (error) {\n        if (!error) {\n          _this.altSetting = 0;\n\n          _this.refresh();\n        }\n\n        if (callback) {\n          callback.call(_this, error);\n        }\n      });\n    };\n\n    if (!closeEndpoints || this.endpoints.length === 0) {\n      next();\n    } else {\n      var n_1 = this.endpoints.length;\n      this.endpoints.forEach(function (ep) {\n        if (ep.direction === 'in' && ep.pollActive) {\n          ep.once('end', function () {\n            if (--n_1 === 0) {\n              next();\n            }\n          });\n          ep.stopPoll();\n        } else {\n          if (--n_1 === 0) {\n            next();\n          }\n        }\n      });\n    }\n  };\n  /**\n   * Returns `false` if a kernel driver is not active; `true` if active.\n   *\n   * The device must be open to use this method.\n   */\n\n\n  Interface.prototype.isKernelDriverActive = function () {\n    return this.device.__isKernelDriverActive(this.id);\n  };\n  /**\n   * Detaches the kernel driver from the interface.\n   *\n   * The device must be open to use this method.\n   */\n\n\n  Interface.prototype.detachKernelDriver = function () {\n    return this.device.__detachKernelDriver(this.id);\n  };\n  /**\n   * Re-attaches the kernel driver for the interface.\n   *\n   * The device must be open to use this method.\n   */\n\n\n  Interface.prototype.attachKernelDriver = function () {\n    return this.device.__attachKernelDriver(this.id);\n  };\n  /**\n   * Sets the alternate setting. It updates the `interface.endpoints` array to reflect the endpoints found in the alternate setting.\n   *\n   * The device must be open to use this method.\n   * @param altSetting\n   * @param callback\n   */\n\n\n  Interface.prototype.setAltSetting = function (altSetting, callback) {\n    var _this = this;\n\n    this.device.__setInterface(this.id, altSetting, function (error) {\n      if (!error) {\n        _this.altSetting = altSetting;\n\n        _this.refresh();\n      }\n\n      if (callback) {\n        callback.call(_this, error);\n      }\n    });\n  };\n  /**\n   * Return the InEndpoint or OutEndpoint with the specified address.\n   *\n   * The device must be open to use this method.\n   * @param addr\n   */\n\n\n  Interface.prototype.endpoint = function (addr) {\n    return this.endpoints.find(function (item) {\n      return item.address === addr;\n    });\n  };\n\n  return Interface;\n}();\n\nexports.Interface = Interface;","map":{"version":3,"mappings":"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","names":["device","id","refresh","Interface","configDescriptor","descriptor","interfaces","altSetting","interfaceNumber","bInterfaceNumber","endpoints","len","length","i","desc","c","bEndpointAddress","bindings_1","endpoint_1","__claimInterface","closeEndpointsOrCallback","callback","closeEndpoints","next","_this","__releaseInterface","error","call","n_1","forEach","ep","direction","pollActive","once","stopPoll","__isKernelDriverActive","__detachKernelDriver","__attachKernelDriver","__setInterface","addr","find","address","exports"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\usb\\interface.ts"],"sourcesContent":["import { LibUSBException, LIBUSB_ENDPOINT_IN, Device } from './bindings';\nimport { InterfaceDescriptor } from './descriptors';\nimport { Endpoint, InEndpoint, OutEndpoint } from './endpoint';\n\nexport class Interface {\n    /** Integer interface number. */\n    public interfaceNumber!: number;\n\n    /** Integer alternate setting number. */\n    public altSetting = 0;\n\n    /** Object with fields from the interface descriptor -- see libusb documentation or USB spec. */\n    public descriptor!: InterfaceDescriptor;\n\n    /** List of endpoints on this interface: InEndpoint and OutEndpoint objects. */\n    public endpoints!: Endpoint[];\n\n    constructor(protected device: Device, protected id: number) {\n        this.refresh();\n    }\n\n    protected refresh(): void {\n        if (!this.device.configDescriptor) {\n            return;\n        }\n\n        this.descriptor = this.device.configDescriptor.interfaces[this.id][this.altSetting];\n        this.interfaceNumber = this.descriptor.bInterfaceNumber;\n        this.endpoints = [];\n        const len = this.descriptor.endpoints.length;\n        for (let i = 0; i < len; i++) {\n            const desc = this.descriptor.endpoints[i];\n            const c = (desc.bEndpointAddress & LIBUSB_ENDPOINT_IN) ? InEndpoint : OutEndpoint;\n            this.endpoints[i] = new c(this.device, desc);\n        }\n    }\n\n    /**\n     * Claims the interface. This method must be called before using any endpoints of this interface.\n     *\n     * The device must be open to use this method.\n     */\n    public claim(): void {\n        this.device.__claimInterface(this.id);\n    }\n\n    /**\n     * Releases the interface and resets the alternate setting. Calls callback when complete.\n     *\n     * It is an error to release an interface with pending transfers.\n     *\n     * The device must be open to use this method.\n     * @param callback\n     */\n    public release(callback?: (error?: LibUSBException) => void): void;\n\n    /**\n     * Releases the interface and resets the alternate setting. Calls callback when complete.\n     *\n     * It is an error to release an interface with pending transfers. If the optional closeEndpoints\n     * parameter is true, any active endpoint streams are stopped (see `Endpoint.stopStream`),\n     * and the interface is released after the stream transfers are cancelled. Transfers submitted\n     * individually with `Endpoint.transfer` are not affected by this parameter.\n     *\n     * The device must be open to use this method.\n     * @param closeEndpoints\n     * @param callback\n     */\n    public release(closeEndpoints?: boolean, callback?: (error?: LibUSBException) => void): void;\n    public release(closeEndpointsOrCallback?: boolean | ((error?: LibUSBException) => void), callback?: (error: LibUSBException | undefined) => void): void {\n\n        let closeEndpoints = false;\n        if (typeof closeEndpointsOrCallback === 'boolean') {\n            closeEndpoints = closeEndpointsOrCallback;\n        } else {\n            callback = closeEndpointsOrCallback;\n        }\n\n        const next = () => {\n            this.device.__releaseInterface(this.id, error => {\n                if (!error) {\n                    this.altSetting = 0;\n                    this.refresh();\n                }\n                if (callback) {\n                    callback.call(this, error);\n                }\n            });\n        };\n\n        if (!closeEndpoints || this.endpoints.length === 0) {\n            next();\n        } else {\n            let n = this.endpoints.length;\n            this.endpoints.forEach(ep => {\n                if (ep.direction === 'in' && (ep as InEndpoint).pollActive) {\n                    ep.once('end', () => {\n                        if (--n === 0) {\n                            next();\n                        }\n                    });\n                    (ep as InEndpoint).stopPoll();\n                } else {\n                    if (--n === 0) {\n                        next();\n                    }\n                }\n            });\n        }\n    }\n\n    /**\n     * Returns `false` if a kernel driver is not active; `true` if active.\n     *\n     * The device must be open to use this method.\n     */\n    public isKernelDriverActive(): boolean {\n        return this.device.__isKernelDriverActive(this.id);\n    }\n\n    /**\n     * Detaches the kernel driver from the interface.\n     *\n     * The device must be open to use this method.\n     */\n    public detachKernelDriver(): void {\n        return this.device.__detachKernelDriver(this.id);\n    }\n\n    /**\n     * Re-attaches the kernel driver for the interface.\n     *\n     * The device must be open to use this method.\n     */\n    public attachKernelDriver(): void {\n        return this.device.__attachKernelDriver(this.id);\n    }\n\n    /**\n     * Sets the alternate setting. It updates the `interface.endpoints` array to reflect the endpoints found in the alternate setting.\n     *\n     * The device must be open to use this method.\n     * @param altSetting\n     * @param callback\n     */\n    public setAltSetting(altSetting: number, callback?: (error: LibUSBException | undefined) => void): void {\n        this.device.__setInterface(this.id, altSetting, error => {\n            if (!error) {\n                this.altSetting = altSetting;\n                this.refresh();\n            }\n            if (callback) {\n                callback.call(this, error);\n            }\n        });\n    }\n\n    /**\n     * Return the InEndpoint or OutEndpoint with the specified address.\n     *\n     * The device must be open to use this method.\n     * @param addr\n     */\n    public endpoint(addr: number): Endpoint | undefined {\n        return this.endpoints.find(item => item.address === addr);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}