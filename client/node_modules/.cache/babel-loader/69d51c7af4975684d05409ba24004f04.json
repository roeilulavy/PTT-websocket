{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar events_1 = require(\"events\");\n\nvar device_1 = require(\"./device\");\n\nvar usb = require(\"./bindings\");\n\nif (usb.INIT_ERROR) {\n  /* eslint-disable no-console */\n  console.warn('Failed to initialize libusb.');\n}\n\nObject.setPrototypeOf(usb, events_1.EventEmitter.prototype);\nObject.getOwnPropertyNames(device_1.ExtendedDevice.prototype).forEach(function (name) {\n  Object.defineProperty(usb.Device.prototype, name, Object.getOwnPropertyDescriptor(device_1.ExtendedDevice.prototype, name) || Object.create(null));\n}); // Polling mechanism for discovering device changes until this is fixed:\n// https://github.com/libusb/libusb/issues/86\n\nvar pollTimeout = 500;\nvar hotplugSupported = usb._getLibusbCapability(usb.LIBUSB_CAP_HAS_HOTPLUG) > 0;\nvar pollingHotplug = false;\nvar pollDevices = new Set();\n\nvar pollHotplug = function (start) {\n  var e_1, _a, e_2, _b;\n\n  if (start === void 0) {\n    start = false;\n  }\n\n  if (start) {\n    pollingHotplug = true;\n  } else if (!pollingHotplug) {\n    return;\n  } // Collect current devices\n\n\n  var devices = new Set(usb.getDeviceList());\n\n  if (!start) {\n    try {\n      // Find attached devices\n      for (var devices_1 = __values(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {\n        var device = devices_1_1.value;\n        if (!pollDevices.has(device)) usb.emit('attach', device);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (devices_1_1 && !devices_1_1.done && (_a = devices_1.return)) _a.call(devices_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    try {\n      // Find detached devices\n      for (var pollDevices_1 = __values(pollDevices), pollDevices_1_1 = pollDevices_1.next(); !pollDevices_1_1.done; pollDevices_1_1 = pollDevices_1.next()) {\n        var device = pollDevices_1_1.value;\n        if (!devices.has(device)) usb.emit('detach', device);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (pollDevices_1_1 && !pollDevices_1_1.done && (_b = pollDevices_1.return)) _b.call(pollDevices_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  }\n\n  pollDevices = devices;\n  setTimeout(function () {\n    pollHotplug();\n  }, pollTimeout);\n};\n\nusb.on('newListener', function (event) {\n  if (event !== 'attach' && event !== 'detach') {\n    return;\n  }\n\n  var listenerCount = usb.listenerCount('attach') + usb.listenerCount('detach');\n\n  if (listenerCount === 0) {\n    if (hotplugSupported) {\n      usb._enableHotplugEvents();\n    } else {\n      pollHotplug(true);\n    }\n  }\n});\nusb.on('removeListener', function (event) {\n  if (event !== 'attach' && event !== 'detach') {\n    return;\n  }\n\n  var listenerCount = usb.listenerCount('attach') + usb.listenerCount('detach');\n\n  if (listenerCount === 0) {\n    if (hotplugSupported) {\n      usb._disableHotplugEvents();\n    } else {\n      pollingHotplug = false;\n    }\n  }\n});\nmodule.exports = usb;","map":{"version":3,"mappings":"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","names":["usb","INIT_ERROR","console","warn","Object","setPrototypeOf","events_1","prototype","getOwnPropertyNames","device_1","forEach","defineProperty","Device","name","getOwnPropertyDescriptor","create","pollTimeout","hotplugSupported","_getLibusbCapability","LIBUSB_CAP_HAS_HOTPLUG","pollingHotplug","pollDevices","Set","pollHotplug","start","devices","getDeviceList","devices_1_1","device","has","emit","pollDevices_1_1","setTimeout","on","event","listenerCount","_enableHotplugEvents","_disableHotplugEvents","module"],"sources":["D:\\Projects\\React\\PTT-react\\client\\node_modules\\usb\\tsc\\usb\\index.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport { ExtendedDevice } from './device';\nimport * as usb from './bindings';\n\nif (usb.INIT_ERROR) {\n    /* eslint-disable no-console */\n    console.warn('Failed to initialize libusb.');\n}\n\nObject.setPrototypeOf(usb, EventEmitter.prototype);\n\nObject.getOwnPropertyNames(ExtendedDevice.prototype).forEach(name => {\n    Object.defineProperty(usb.Device.prototype, name, Object.getOwnPropertyDescriptor(ExtendedDevice.prototype, name) || Object.create(null));\n});\n\ninterface EventListeners<T> {\n    newListener: keyof T;\n    removeListener: keyof T;\n}\n\ndeclare module './bindings' {\n\n    /* eslint-disable @typescript-eslint/no-empty-interface */\n    interface Device extends ExtendedDevice { }\n\n    interface DeviceEvents extends EventListeners<DeviceEvents> {\n        attach: Device;\n        detach: Device;\n    }\n\n    function addListener<K extends keyof DeviceEvents>(event: K, listener: (arg: DeviceEvents[K]) => void): void;\n    function removeListener<K extends keyof DeviceEvents>(event: K, listener: (arg: DeviceEvents[K]) => void): void;\n    function on<K extends keyof DeviceEvents>(event: K, listener: (arg: DeviceEvents[K]) => void): void;\n    function off<K extends keyof DeviceEvents>(event: K, listener: (arg: DeviceEvents[K]) => void): void;\n    function once<K extends keyof DeviceEvents>(event: K, listener: (arg: DeviceEvents[K]) => void): void;\n    function listeners<K extends keyof DeviceEvents>(event: K): ((arg: DeviceEvents[K]) => void)[];\n    function rawListeners<K extends keyof DeviceEvents>(event: K): ((arg: DeviceEvents[K]) => void)[];\n    function removeAllListeners<K extends keyof DeviceEvents>(event?: K): void;\n    function emit<K extends keyof DeviceEvents>(event: K, arg: DeviceEvents[K]): boolean;\n    function listenerCount<K extends keyof DeviceEvents>(event: K): number;\n}\n\n// Polling mechanism for discovering device changes until this is fixed:\n// https://github.com/libusb/libusb/issues/86\nconst pollTimeout = 500;\nconst hotplugSupported = usb._getLibusbCapability(usb.LIBUSB_CAP_HAS_HOTPLUG) > 0;\nlet pollingHotplug = false;\nlet pollDevices = new Set<usb.Device>();\n\nconst pollHotplug = (start = false) => {\n    if (start) {\n        pollingHotplug = true;\n    } else if (!pollingHotplug) {\n        return;\n    }\n\n    // Collect current devices\n    const devices = new Set(usb.getDeviceList());\n\n    if (!start) {\n        // Find attached devices\n        for (const device of devices) {\n            if (!pollDevices.has(device))\n                usb.emit('attach', device);\n        }\n\n        // Find detached devices\n        for (const device of pollDevices) {\n            if (!devices.has(device))\n                usb.emit('detach', device);\n        }\n    }\n\n    pollDevices = devices;\n    setTimeout(() => {\n        pollHotplug();\n    }, pollTimeout);\n};\n\nusb.on('newListener', event => {\n    if (event !== 'attach' && event !== 'detach') {\n        return;\n    }\n    const listenerCount = usb.listenerCount('attach') + usb.listenerCount('detach');\n    if (listenerCount === 0) {\n        if (hotplugSupported) {\n            usb._enableHotplugEvents();\n        } else {\n            pollHotplug(true);\n        }\n    }\n});\n\nusb.on('removeListener', event => {\n    if (event !== 'attach' && event !== 'detach') {\n        return;\n    }\n    const listenerCount = usb.listenerCount('attach') + usb.listenerCount('detach');\n    if (listenerCount === 0) {\n        if (hotplugSupported) {\n            usb._disableHotplugEvents();\n        } else {\n            pollingHotplug = false;\n        }\n    }\n});\n\nexport = usb;\n"]},"metadata":{},"sourceType":"script"}